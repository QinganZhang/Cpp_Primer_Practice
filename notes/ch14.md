# 第十四章 重载运算与类型转换

## 基本概念

- 重载运算符是具有特殊名字的函数：由关键字`operator`和其后要定义的运算符号共同组成。
- 重载运算符函数的参数数量和该运算符作用的运算对下个数量一样多，左侧运算对象传递过第一个参数，右侧传递给第二个，除了重载函数调用符`()`，其他重载运算符不能有默认实参
  - 如果一个重载的运算符是成员函数，**`this`绑定到左侧运算对象**。
- 只能重载大多数的运算符，而不能发明新的运算符号。
- 重载运算符的优先级和结合律跟对应的内置运算符保持一致。
- 调用方式：
  - `data1 + data2;`
  - `operator+(data1, data2);`
  - `data1 += data2;`
  - `data1.operator+=(data2);`
- 建议
  - 只有当操作的含义对于用户来说清晰明了时，才使用重载运算符，重载本本返回类型应该与内置版本的返回类型兼容
  - 如果类中有算数运算符或位运算符，最好也提供对应的复合赋值运算符。
- 定义为成员函数还是普通函数？
  - 赋值（`=`）、下标（`[]`）、调用（`()`）和成员访问箭头（`->`）运算符必须是成员。
  - 复合赋值运算符一般来说是成员，但非必须。
  - 改变对象状态的运算符或者和给定类型密切相关的运算符通常是成员，如递增、解引用。
  - 具有对称性的运算符如算术、相等性、关系和位运算符等，通常是非成员函数。

**运算符**:

| 可以被重载 | 不可以被重载 |
|-----|-----|
| `+`, `-`, `*`, `/`, `%`, `^` | `::`, `.*`, `.`, `? :`, |
| `&`, `|`, `~`, `!`, `,`, `=` |  |
| `<`, `>`, `<=`, `>=`, `++`, `--` |  |
| `<<`, `>>`, `==`, `!=`, `&&`, `||` |  |
| `+=`, `-=`, `/=`, `%=`, `^=`, `&=` |  |
| &#124;=, `*=`, `<<=`, `>>=`, `[]`, `()` |  |
| `->`, `->*`, `new`, `new[]`, `delete`, `delete[]` |  |

## 输入和输出运算符

### 重载输出运算符<<

- `ostream& operator<< (ostream &os, const T &t);`
  - 第一个形参通常是一个非常量的`ostream`对象的引用，第二个形参是要打印类型的常量引用
    - 非常量是因为向流中写入会改变其状态；而引用是因为我们无法复制一个`ostream`对象。
- 输出运算符应该尽量减少格式化操作
- 输入输出运算符必须是非成员函数，但是由于IO操作通常需要读写非公有数据，因此输入输出运算符一般被声明为友元

### 重载输入运算符>>

- `istream& operator>> (istream& is, T &t);`
  - 第一个形参通常是运算符将要读取的流的引用，第二个形参是将要读取到的（非常量）对象的引用。
- 输入运算符必须处理输入可能失败的情况，而输出运算符不需要。
  - 比如判断is输入流是否为空、设置流的条件状态以标识出失败信息（通常输入运算符只设置failbit状态，eofbit、badbit等由IO标准库自己标示）

## 算数和关系运算符（+、-、*、/）

- 通常情况下，算数和关系运算符应该设置为非成员函数，形参一般为常量引用，返回值不为引用（因为返回值一般是局部变量的拷贝）
- 如果类同时定义了算数运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算数运算符。

### 相等运算符==

- 如果定义了`operator==`，则这个类也应该定义`operator!=`。
  - 相等运算符和不等运算符的一个应该把工作委托给另一个
- 相等运算符应该具有传递性。
- 如果某个类在逻辑上有相等性的含义，则该类应该定义`operator==`，这样做可以使用户更容易使用标准库算法来处理这个类。

### 关系运算符

- 如果存在唯一一种逻辑可靠的`<`定义，则应该考虑为这个类定义`<`运算符。
  - 如果两个对象是!=的，则一个对象应该<另一个对象
  - 如果同时还包含`==`，则当且仅当`<`的定义和`==`产生的结果一直时才定义`<`运算符。

## 赋值运算符=

- 赋值运算符都必须定义为成员函数。
- 赋值运算符和复合赋值运算符应该返回左侧运算对象的引用。

## 下标运算符[]

- 下标运算符必须是成员函数。
- 一般会定义两个版本：
  - 返回普通引用：`T& operator[]();`
  - 返回类的常量成员，并返回常量引用：`const T& operator[] const;`

## 递增和递减运算符（++、--）

- 定义递增和递减运算符的类应该同时定义前置版本和后置版本，通常应该被定义成类的成员。
- 为了和内置版本保持一致
  - 前置运算符应该返回递增或递减后对象的引用：`string& operator++();`
  - 后置运算符应该返回递增或递减前对象的值，而不是引用：`T operator++(int);`
    - 后置版本接受一个额外的，不被使用的`int`类型的形参。因为不会用到，所以无需命名。该形参唯一的作用就是区分前置和后置递增
    - 如果想通过函数调用的方式使用后置递增，需要为这个int形参传递一个值（比如0）

## 成员访问运算符（*、->）

- 箭头运算符必须是类的成员。解引用运算符通常也是类的成员，且通常为const的成员函数。
- 重载的箭头运算符必须返回【类的指针】或者【自定义了箭头运算符的某个类的对象】，比如`point->mem`
  - 如果point是指向类对象的指针：`point->mem`等价于`(*point).mem`
  - 如果point是重载了`operator->`类的对象，`point->mem`等价于`point.operator()->mem`
- 解引用和乘法的区别是一个是一元运算符，一个是二元运算符。

## 函数调用运算符

- 可以像使用函数一样，调用该类的对象。因为这样对待类同时也能存储状态，所以与普通函数相比更加灵活。
- 函数调用运算符必须是成员函数。
- 一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。
- 如果类定义了调用运算符，则该类的对象称作**函数对象**。

### `lambda`是函数对象

- 编写一个lambda表达式后，编译器将该表达式转换成【一个未命名类的未命名对象】，类中含有【一个重载的函数调用运算符】
  - 这个产生的类不包含默认构造函数、赋值运算符和默认析构函数，它是否包含默认拷贝/移动构造函数，通常视捕获变量的类型而定
- lambda默认不能改变它捕获的变量，因此默认情况下，lambda表达式产生的类中的函数调用运算符是一个const成员函数；如果lambda被声明为可变的，则调用运算符就不再是const的
  - 如果进行引用捕获，编译器直接使用该引用而无须在产生的类中相应存储为数据成员（由程序确保该引用绑定的对象确实存在）
  - 如果进行值捕获，产生的类必须为捕获的变量建立对应的数据成员，并创建构造函数，用捕获变量的值来初始化相应的数据成员

### 标准库定义的函数对象

**标准库函数对象**:

| 算术 | 关系 | 逻辑 |
|-----|-----|-----|
| `plus<Type>` | `equal_to<Type>` | `logical_and<Type>` |
| `minus<Type>` | `not_equal_to<Type>` | `logical_or<Type>` |
| `multiplies<Type>` | `greater<Type>` | `logical_not<Type>` |
| `divides<Type>` | `greater_equal<Type>` |  |
| `modulus<Type>` | `less<Type>` |  |
| `negate<Type>` | `less_equal<Type>` |  |

- 一组带模板的类，比如`less<int>()`进行类的初始化
- 可以在算法中使用标准库函数对象，比如替换算法中的默认运算符
- 如果想根据指针（或者说内存地址）进行排序，Type可以是指针类型，但是无法通过自定义的函数来进行内存地址的比较

### 可调用对象与function

**标准库function类型**：

| 操作 | 解释 |
|-----|-----|
| `function<T> f;` | `f`是一个用来存储可调用对象的空`function`，这些可调用对象的调用形式应该与类型`T`相同。 |
| `function<T> f(nullptr);` | 显式地构造一个空`function` |
| `function<T> f(obj)` | 在`f`中存储可调用对象`obj`的副本 |
| `f` | 将`f`作为条件：当`f`含有一个可调用对象时为真；否则为假。 |
| 定义为`function<T>`的成员的类型 |  |
| `result_type` | 该`function`类型的可调用对象返回的类型 |
| `argument_type` | 当`T`有一个或两个实参时定义的类型。如果`T`只有一个实参，则`argument_type` |
| `first_argument_type` | 第一个实参的类型 |
| `second_argument_type` | 第二个实参的类型 |

- 例如：声明一个`function`类型，它可以表示接受两个`int`，返回一个`int`的可调用对象。`function<int(int, int)>`
  ```c++
    // ordinary function
    int add(int i, int j) { return i + j; }
    // function-object class
    struct div
    {
        int operator()(int denominator, int divisor)
        {
            return denominator / divisor;
        }
    };

    function<int(int, int)> f1 = add;      // function pointer
    function<int(int, int)> f2 = div();    // object of a function-object class
    function<int(int, int)> f3 = [](int i, int j) { return i * j; };  // lambda

    cout << f1(4,2) << endl;   // prints 6
    cout << f2(4,2) << endl;   // prints 2
    cout << f3(4,2) << endl;   // prints 8    
  ```
- 不能直接将重载函数的名字存入`function`类型的对象中，因为会产生二义性，消除二义性的方法是使用lambda或者函数指针而非函数名字  

## 重载、类型转换、运算符

### 类型转换运算符

- 类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下：`operator type() const;`
- 一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是`const`。
- 避免过度使用类型转换函数。
- C++11引入了显式的类型转换运算符。
- 向`bool`的类型转换通常用在条件部分，因此`operator bool`一般定义成`explicit`的。

### 避免有二义性的类型转换

- 通常，不要为类第几个亿相同的类型转换，也不要在类中定义两个及以上转换源或转换目标是算术类型的转换。
- 在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。

### 函数匹配与重载运算符

- 如果`a`是一种类型，则表达式`a sym b`可能是：
  - `a.operatorsym(b);`
  - `operatorsym(a,b);`
- 如果我们队同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。
