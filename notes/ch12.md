# 第十二章 动态内存

- 对象的生命周期：
  - 全局对象在程序启动时分配，结束时销毁。
  - 局部对象在进入程序块时创建，离开块时销毁。
  - 局部`static`对象在第一次使用前分配，在程序结束时销毁。
  - 动态分配对象：只能显式地被释放。

- 对象的内存位置：
  - **静态内存**用来保存局部`static`对象、类`static`对象、定义在任何函数之外的变量。
  - **栈内存**用来保存定义在函数内的非`static`对象；由操作系统自动分配和释放，内存空间大小比较小
  - **堆内存**，又称自由空间，用来存储**动态分配**的对象；手动申请和释放，内存空间比较大

## 动态内存与智能指针

- 动态内存管理：
  - `new`：在动态内存中为对象分配空间并返回一个指向该对象的指针。
  - `delete`：接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。
- 智能指针：
  - 特点：
    - 管理动态对象。
    - 行为类似常规指针。
    - 负责自动释放所指向的对象。
    - 智能指针也是模板。
  - 类型：定义在头文件`memory`中
    - `shared_ptr`：允许多个指针指向同一个对象
    - `unique_ptr`：独占所指向的对象
    - `weak_ptr`：是一种弱引用，指向`shared_ptr`所管理的对象

### shared_ptr类

**shared_ptr和unique_ptr都支持的操作**：

| 操作 | 解释 |
|-----|-----|
| `shared_ptr<T> sp`  `unique_ptr<T> up` | 空智能指针，可以指向类型是`T`的对象 |
| `p` | 将`p`用作一个条件判断，若`p`指向一个对象，则为`true` |
| `*p` | 解引用`p`，获得它指向的对象。 |
| `p->mem` | 等价于`(*p).mem` |
| `p.get()` | 返回`p`中保存的指针，要小心使用，若智能指针释放了对象，返回的指针所指向的对象也就消失了。 |
| `swap(p, q)` `p.swap(q)` | 交换`p`和`q`中的指针 |

**shared_ptr独有的操作**：

| 操作 | 解释 |
|-----|-----|
| `make_shared<T>(args)` | 返回一个`shared_ptr`，指向一个动态分配的类型为`T`的对象。使用`args`初始化此对象（初始化方法必须与某个构造函数相匹配）。 |
| `shared_ptr<T>p(q)` | `p`是【`shared_ptr q`】的拷贝；此操作会**递增**`q`中的计数器（可以认为每个shared_ptr都有（或关联）一个引用计数）。`q`中的指针必须能转换为`T*` |
| `p = q` | `p`和`q`都是`shared_ptr`，所保存的指针必须能互相转换。此操作会**递减**`p`的引用计数，**递增**`q`的引用计数；若`p`的引用计数变为0，则将其管理的原内存释放。 |
| `p.unique()` | 若`p.use_count()`是1，返回`true`；否则返回`false` |
| `p.use_count()` | 返回与`p`共享对象的智能指针数量；可能很慢，主要用于调试。 |

- 保证shared_ptr在无用之后不再保留：如果将shared_ptr存放在一个容器中，但是重排了容器，某个元素不再需要，这时应该用erase删除不再需要的shared_ptr元素
- 智能指针不支持指针算数运算

- **使用动态内存的三种原因**：
  - 程序不知道自己需要使用多少对象（比如容器类）。
  - 程序不知道所需要对象的准确类型。
  - 程序需要在多个对象间共享数据（数据只有一份），而非多个对象各自有一份数据的拷贝
    - 更准确的来说，一般类中，分配的资源与类的对象声明周期一致，每个类拥有自己的资源，拷贝类时将资源复制一份
    - 但是有时希望不同拷贝之间共享相同的资源，即**允许多个对象共享相同的状态**

### 直接管理内存

- 用`new`动态分配和初始化对象。
  - 使用`new`动态分配内存，返回的是一个指向该对象的指针。
  - 动态分配的对象是默认初始化的，也可以使用值初始化、直接初始化（圆括号方式）、列表初始化方式来进行初始化
  - 可以使用auto进行初始化，但是只有初始化的括号中仅有单一初始化器时才可以使用auto
  - 可以使用new分配const对象，返回指向const类型的指针，但是动态分配的const对象必须初始化
  - 如果new无法分配到所要求的内存空间，则会抛出`bad_alloc`异常
    - 使用定位new可以阻止抛出异常，定位new允许将new传递额外参数；如果传递`nothrow`给new，则new在分配失败之后会返回空指针
  - 例子：
    ```c++
      int* pi = new int;
      string* ps = new string("test");
      vector<int>* pv = new vector<int>{1,2,3,4};

      auto pc1 = new auto{'a'};   // 只有初始化的括号中仅有单一初始化器时才可以使用auto
      auto pc2 = new auto('a');

      const string* cps = new string("const test"); // 必须初始化

      int* p = new (nothrow) int;  
  ```

- 用`delete`将动态内存归还给系统。
  - 使用delete释放一块并非new分配的内存，或者将相同的指针值释放多次的行为是未定义的
  - `delete`后的指针称为空悬指针（dangling pointer），应该在delete之后将指针值置空。
- 使用`new`和`delete`管理动态内存存在三个常见问题：
  - 1.忘记`delete`内存（内存泄漏）
  - 2.使用已经释放掉的对象。
  - 3.同一块内存释放两次。
- 坚持只使用智能指针可以避免上述所有问题。

### shared_ptr和new结合使用

**定义和改变shared_ptr的其他方法**：

| 操作 | 解释 |
|-----|-----|
| `shared_ptr<T> p(q)` | `p`管理【内置指针`q`】 所指向的对象；`q`必须指向`new`分配的内存，且能够转换为`T*`类型 |
| `shared_ptr<T> p(u)` | `p`从`unique_ptr u`那里接管了对象的所有权；将`u`置为空 |
| `shared_ptr<T> p(q, d)` | `p`接管了【内置指针`q`】所指向的对象的所有权。`q`必须能转换为`T*`类型。`p`将使用【可调用对象`d`】来代替`delete`。 |
| `shared_ptr<T> p(p2, d)` | `p`是【`shared_ptr p2`】的拷贝，唯一的区别是`p`将【可调用对象`d`】来代替`delete`。 |
| `p.reset()` | 若`p`是唯一指向其对象的`shared_ptr`，`reset`会释放此对象。 |
| `p.reset(q)` | 更新引用计数：若传递了【内置指针`q`】，会令`p`指向`q`。 |
| `p.reset(q, d)` | 若还传递了参数`d`，则会调用`d`而不是`delete`来释放`q`。 |

- 智能指针与内置指针
  - 可以使用new返回的指针初始化智能指针，但是必须使用直接初始化形式（圆括号初始化）
  - 用来初始化智能指针的指针必须指向动态内存，智能指针默认使用delete释放它所管理的对象
  - 不要混合使用智能指针和内置指针，使用智能指针进行资源的管理，使用内置指针访问智能指针的资源是危险的（因为不知道对象何时被销毁）
  - 例子：
  ```c++
    void add(shared_ptr<int> p) {++(*p);}
    int* p1 = new int(1), *p2 = new int(2);
    shared_ptr<int> spi(p1);
    add(spi); // 传值参数，spi内部引用计数为2
    // 此时spi（指向p1的）引用计数为1

    add(shared_ptr<int>(p2)); // 传递一个临时shared_ptr，内部引用计数为1
    // 此时临时shared_ptr引用计数为0， 指向的变量（p2）内存被释放，访问p2是未定义的  
  ```
  
- 智能指针的`get`函数
  - 智能指针的`get`函数返回一个内置指针，指向智能指针管理的对象，主要用于向不能使用智能指针的代码传递内置指针。使用get返回的指针不能用来delete
  - 不要使用get函数初始化另一个智能指针或为智能指针赋值（主要是因为析构时多次delete）
  - 只有在确定代码不会delete指针的情况下，才使用get
  - 例子：
  ```c++
    shared_ptr<int> p(new int(1));
    int *q = p.get();
    {
        shared_ptr<int> tmp(q);
    } // tmp结束生命周期，引用计数为0，指向的内存q被释放
    // 此时使用p是未定义的，指向的内存已经被释放；而且程序结束时，p会再次delete该内存  
  ```

- 智能指针的unique
  - 例子：
  ```c++
    shared_ptr<int> p(new int(1));
    if(!p.unique()) // 如果p指向的对象还有其他shared_ptr指向
        p.reset(new int(1)); // 则改变之前制作一份拷贝，reset函数将新的指针赋予shared_ptr，同时会更新引用计数
    *p += 1; // 现在确定p指向的内存是unique的，可以修改  
  ```


### 智能指针和异常

- **智能指针陷阱**：
  - 不使用相同的内置指针初始化或`reset`多个智能指针
  - 不`delete get()`返回的指针。
  - 不使用`get()`初始化或`reset`另一个智能指针
  - 如果你使用`get()`返回的指针，记得当最后一个对应的智能指针销毁后，你的指针就无效了。
  - 如果你使用智能指针管理的资源不是`new`分配的内存，记住传递给它一个删除函数。

### unique_ptr

**unique_ptr操作**:

| 操作 | 解释 |
|-----|-----|
| `unique_ptr<T> u1` | 空`unique_ptr`，可以指向类型是`T`的对象。`u1`会使用`delete`来是释放它的指针。 |
| `unique_ptr<T, D> u2` | `u2`会使用一个【类型为`D`的可调用对象】来释放它的指针。 |
| `unique_ptr<T, D> u(d)` | 空`unique_ptr`，指向类型为`T`的对象，用【类型为`D`的对象`d`】代替`delete` |
| `u = nullptr` | 释放`u`指向的对象，将`u`置为空。 |
| `u.release()` | `u`放弃对指针的控制权（注意不会释放指向对象的内存），返回指针，并将`u`置空。 |
| `u.reset()` | 释放`u`指向的对象 |
| `u.reset(q)` | 令`u`指向`q`指向的对象，u原来指向的对象被释放 |
| `u.reset(nullptr)` | 将`u`置空 |

- 同一时刻只能有一个`unique_ptr`指向一个给定的对象。当unique_ptr被销毁时，它指向的对象也被销毁
- `make_unique`函数（C++14）类似于`make_shared`，在动态内存中分配一个对象并初始化，返回指向该对象的`unique_ptr`
- unique_ptr独占其指向的对象，不支持拷贝或者赋值操作。
  - 例外：可以拷贝或赋值一个即将被销毁的unique_ptr（移动构造、移动赋值）
  - 例子：
  ```c++
    unique_ptr<int> clone(int i){
      unique_ptr<int> p(new int(i));  
      return p; // 返回一个局部对象的拷贝
      // return unique_ptr<int>(new int(i)); // 或者直接返回一个局部对象
    }
  ```
- release返回的指针通常用来初始化另一个智能指针(reset)或给智能指针赋值
  - 例子：
  ```c++
    unique_ptr<int> p1(new int(1)), p2(new int(2));
    p1.release(); // p1放弃了对象的控制权，对象的内存没有释放，而且对象的指针丢失
    int* p = p2.release(); // 使用p保存对象的指针，但是后续需要使用delete(p)释放内存
  ```  
- 老版本的标准库包含了一个名为`auto_ptr`的类，具有`unique_ptr`的部分特性。
- 注意传递删除函数时必须在类型中提供删除器类型


### weak_ptr

**weak_ptr操作**:

| 操作 | 解释 |
|-----|-----|
| `weak_ptr<T> w` | 空`weak_ptr`可以指向类型为`T`的对象 |
| `weak_ptr<T> w(sp)` | 与`shared_ptr`指向相同对象的`weak_ptr`。`T`必须能转换为`sp`指向的类型。 |
| `w = p` | `p`可以是`shared_ptr`或一个`weak_ptr`。赋值后`w`和`p`共享对象。 |
| `w.reset()` | 将`w`置为空。 |
| `w.use_count()` | 与`w`共享对象的`shared_ptr`的数量。 |
| `w.expired()` | 若`w.use_count()`为0，返回`true`，否则返回`false` |
| `w.lock()` | 如果`expired`为`true`，则返回一个空`shared_ptr`；否则返回一个指向`w`的对象的`shared_ptr`。 |

- `weak_ptr`是一种不控制所指向对象生存期的智能指针。
- 指向一个由`shared_ptr`管理的对象，将`weak_ptr`绑定到`shared_ptr`，不改变`shared_ptr`的引用计数。
- 如果shared_ptr被销毁，即使有weak_ptr指向对象，对象仍然可能被释放
- 使用weak_ptr访问对象时，必须先调用lock函数，以检查指向的对象是否仍然存在
  - 例子：
  ```c++
    shared_ptr<int> sp = make_shared<int>(1);
    weak_ptr<int> wp(sp);
    if (shared_ptr<int> p = w.lock()) cout<<*p<<endl;
  ```

## 动态数组

### new和数组

- `new`一个动态数组，返回指向第一个对象的指针（返回的指针不是数组类型，而是数组元素类型）
- 由于new分配的内存不是数组类型（比如`int[10]`），因此不能对动态数组调用begin和end，也不能使用range-for遍历元素
- new的数组可以进行值初始化、列表初始化
  ```c++
    const int sz = 10;
    int *p1 = new int[sz]; // 没有初始化
    int *p2 = new int[sz](); // 值初始化为0
    int *p3 = new int[sz]{1,2,3,4,5}; // 列表初始化  
  ```
- 动态分配一个空数组是合法的，此时返回一个合法的非空指针，类似于尾后指针
- 使用`delete []`释放动态数组


##### `unique_ptr`和数组：
- 可以使用unique_ptr管理new分配的数组
```c++
  unique_ptr<int[]> p(new int[10]()); // p指向一个包含10个元素的int数组，数组元素使用0进行初始化
  p.release(); // 自动用delete[]销毁其指针
```
- 指向数组的`unique_ptr`不支持成员访问运算符（点和箭头）。
  
##### `shared_ptr`和数组：
- 如果想用`shared_ptr`管理动态数组，必须提供自定义的删除器
- `shared_ptr`未定义下标运算符，智能指针也不支持指针算数运算。可以通过get函数获取内置指针再进行访问
```c++
shared_ptr<int> p(new int[10](), [](int *p){delete []p;}
for(int i=0; i<10; ++i)
  cout<<*(p.get()+i)<<" ";
```
  
### allocator类

- 定义在头文件`memory`中。
- 标准库`allocator`类定义在头文件`memory`中，帮助我们将内存分配和对象构造分离开。
- 分配的是原始的、未构造的内存，程序需要再内存中构造对象。（直接使用未构造的内存是未定义的行为）
- 对象使用完之后，需要对每个构造的元素调用destroy进行销毁

**标准库allocator类及其算法**：

| 操作 | 解释 |
|-----|-----|
| `allocator<T> a` | 定义了一个名为`a`的`allocator`对象，它可以为类型为`T`的对象分配内存 |
| `a.allocate(n)` | 分配一段原始的、未构造的内存，保存`n`个类型为`T`的对象。 |
| `a.deallocate(p, n)` | 释放从`T*`指针`p`中地址开始的内存，这块内存保存了`n`个类型为`T`的对象；`p`必须是一个先前由`allocate`返回的指针。且`n`必须是`p`创建时所要求的大小。在调用`deallocate`之前，用户必须对每个在这块内存中创建的对象调用`destroy`。 |
| `a.construct(p, args)` | `p`必须是一个类型是`T*`的指针，指向一块原始内存；`args`被传递给类型为`T`的构造函数，用来在`p`指向的内存中构造一个对象。 |
| `a.destroy(p)` | `p`为`T*`类型的指针，此算法对`p`指向的对象执行析构函数。 |

**allocator伴随算法**：

| 操作 | 解释 |
|-----|-----|
| `uninitialized_copy(b, e, b2)` | 从【迭代器`b`和`e`给定的输入范围】中拷贝元素到【迭代器`b2`指定的未构造的原始内存】中。`b2`指向的内存必须足够大，能够容纳输入序列中元素的拷贝。 |
| `uninitialized_copy_n(b, n, b2)` | 从迭代器`b`指向的元素开始，拷贝`n`个元素到【`b2`开始的未构造内存】中。 |
| `uninitialized_fill(b, e, t)` | 在【迭代器`b`和`e`指向的原始内存范围】中创建对象，对象的值均为`t`的拷贝。 |
| `uninitialized_fill_n(b, n, t)` | 从【迭代器`b`指向的原始内存地址】开始创建`n`个对象。`b`必须指向足够大的未构造的原始内存，能够容纳给定数量的对象。 |
- 返回最后一个构造元素的尾后位置
- 例子：13.5中的StrVec示例
