# 第十三章 拷贝控制

先复习一下构造函数：
- 默认构造函数
  - 合成的默认构造函数：编译器创建
  - 无参数默认构造函数，最好用`=default`来修饰默认构造函数
  - 带默认值的构造函数
- 一般构造函数：
- 拷贝构造函数（或称为复制构造函数）：根据一个已存在的对象复制出一个新的对象，使用=进行拷贝构造
- 转换构造函数（或称为隐式的类型转换）
- 移动构造函数：经常用于临时对象初始化新对象时
- 委托构造函数：一个构造函数调用另一个构造函数
- 参考：[C++中的五种构造函数](https://blog.csdn.net/TABE_/article/details/116714304)、[C++的几种构造函数](https://blog.csdn.net/weixin_45677333/article/details/108933364)

初始化类型：
- 直接初始化：使用圆括号进行初始化
- 拷贝初始化：`=`
- 列表初始化：`{}`

**拷贝控制操作**（copy control）（或者称为拷贝控制成员）:
一个类通过定义五种特殊的成员函数来控制对象的拷贝、移动、赋值、和销毁操作：
- 拷贝构造函数（copy constructor）
- 拷贝赋值运算符（copy-assignment operator）
- 移动构造函数（move constructor）
- 移动赋值函数（move-assignement operator）
- 析构函数（destructor）

## 拷贝、赋值和销毁

### 拷贝构造函数(The Copy Constructor)

- 如果一个构造函数的第一个参数是**自身类类型的引用**（几乎总是const引用），且任何额外参数都有默认值，则此构造函数是**拷贝构造函数**。
  - `class Foo{ public: Foo(const Foo&); }`
- 拷贝构造函数在一些情况下会被隐式使用，所以通常不会声明为explicit的
- **合成的拷贝构造函数**（synthesized copy constructor）：类未定义自己的拷贝构造函数，编译器为类创建一个，会将参数的非static成员逐个拷贝到正在创建的对象中。
- **拷贝初始化**：
  - 将右侧运算对象拷贝到正在创建的对象中，如果需要，还需进行类型转换。
  - 通常使用拷贝构造函数完成。但如果一个类拥有移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数完成。
  - 出现场景：
    - 用`=`定义变量时。
    - 将一个对象作为实参传递给一个非引用类型的形参。
    - 从一个返回类型为非引用类型的函数返回一个对象。
    - 用花括号列表初始化一个数组中的元素或者一个聚合类中的成员。

### 拷贝赋值运算符(The Copy-Assignment Operator)

- **重载赋值运算符**：
  - 重写一个名为`operator=`的函数，通常返回一个指向其左侧运算对象的引用。
  - 标准库通常要求保存在容器中的元素中的类型要有赋值运算符，且其返回值是左侧对象的引用（`return *this;`）
  - `Foo& operator=(const Foo&);`
- **合成拷贝赋值运算符**：
  - 将右侧运算对象的每个非`static`成员赋予左侧运算对象的对应成员，之后返回左侧对象的引用

### 析构函数

- 释放对象所使用的资源，并销毁对象的非`static`数据成员。
- 名字由波浪号接类名构成。没有返回值，也不接受参数（因此不能被重载）。
- 如果没有定义析构函数，编译器会为类合成一个。合成析构函数的函数体为空。
- 析构函数体与数据成员的销毁是两个步骤（析构函数体本身并不直接销毁成员）
  - 函数体释放对象在生成周期分配的所有资源
  - 析构阶段：数据成员按照初始化顺序的逆序进行销毁，这部分是隐式的，成员销毁时发生什么完全依赖于成员的类型
    - 内置类型没有析构函数，因此销毁内置类型成员什么也不会发生
    - 隐式销毁一个内置指针类型不会delete它所指的对象，因此要在函数体中将指针所指的资源释放
    - 与普通指针不同，智能指针是一个类类型，具有析构函数，因此智能指针成员在析构阶段自动销毁
- 调用时机：
  - 变量在离开其作用域时。
  - 当一个对象被销毁时，其成员被销毁。
  - 容器被销毁时，其元素被销毁。
  - 动态分配的对象，当对指向它的指针应用`delete`运算符时。
  - 对于临时对象，当创建它的完整表达式结束时。

### 三/五法则

- 背景：一个类通常需要拷贝构造函数、拷贝赋值运算符、析构函数、移动构造函数、移动赋值运算符，部分操作会搭配使用，但是通常自己不会全部自定义
- 需要析构函数的类也需要拷贝和赋值操作：一个需要析构函数的类，一定也需要一个拷贝构造函数和拷贝赋值函数（比如类中有一个指向动态内存的指针）
- 需要拷贝操作的类也需要赋值操作，反之亦然（但未必需要析构函数）

### 使用=default

- 可以通过将拷贝控制成员定义为`=default`来显式地要求编译器生成合成的版本。
  - 只能对具有合成版本的成员函数【即默认构造函数或拷贝控制成员】使用=default
- 在类内部使用=default修饰成员声明时，合成的函数是隐式内联的；如果不希望合成的是内联函数，应该只对成员的类外定义使用=defalut

### 阻止拷贝（Preventing Copies）

- 背景：有的类需要禁止拷贝（比如iostream），但是单纯不定义拷贝控制成员是无效的，因为编译器会生成合成的版本。
- 语法：`=delete`，使用位置同=default，作用是禁用修饰的函数
  - =delete必须出现在函数第一次声明的地方（即告诉编译器不定义这些函数），而且可以对任何函数使用（但主要用途是禁止拷贝控制成员）
  - =delete不能修饰类或类成员的析构函数，否则类或类成员无法被销毁
    - 对于=delete修饰类或类成员的析构函数的情况，不能定义该类型的变量或成员，但是可以动态分配(new)该类型的对象，只是无法释放对象内存
- 使用场景与注意事项：
  - =delete修饰【拷贝构造函数和拷贝赋值函数】，可以禁止类对象的拷贝
  - 合成的拷贝控制成员可能是删除的
    - 如果一个类有数据成员不能被构造、拷贝、复制或销毁，则对应的成员函数（构造、拷贝、复制或销毁）将被定义为删除的
- 老版本使用`private`声明来阻止拷贝。
  - 声明但不定义private的拷贝构造函数，类不能使用该拷贝构造函数，友元试图访问一个未定义的成员导致一个编译阶段的链接错误

## 拷贝控制和资源管理

- 通常，管理类外资源的类必须定义拷贝控制成员
- 类的行为可以像一个值，也可以像一个指针（不允许拷贝和赋值的类，行为既不像值，也不像指针），主要是如何拷贝类的指针成员的行为：
  - 行为像值：对象有自己的状态，副本和原对象是完全独立的。
    - 拷贝赋值运算符要考虑到【自赋值】（对象赋予自身）的正确性：
      - 好的方法是先将右侧对象（动态内存的指针对象）拷贝到一个局部临时对象，再销毁左侧对象的资源。（P454）
  - 行为像指针：共享状态，拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。
    - 最好使用shared_ptr管理资源，或者使用一个引用计数来直接管理（引用计数和资源一样是共享的）
    - 拷贝赋值运算符类似于shared_ptr，需要递增右侧对象的引用计数，递减左侧对象的引用计数
    - 此时处理【自赋值】问题：先是右侧对象引用计数递增，后是左侧对象引用计数递减，自赋值时引用计数不变（P457）

## 交换操作

- 管理资源的类通常还定义一个名为`swap`的函数，经常用于重排元素顺序的算法。
- 如果类没有定义自己的swap函数，就使用标准库定义的swap
- 如果存在特定类型的swap版本，匹配程度会优先于std中定义的版本（重载），尽量用自定义的swap
- 定义了swap的类通常用swap来是实现赋值运算符
  - 右侧对象传值，然后将左侧对象与右侧对象的副本进行交换（copy and swap），可以正确处理自赋值的情况
- 例子：
  ```c++
    class HasPtr{
        friend void swap(HasPtr&, HasPtr&);
    public:
        HasPtr(const std::string &s = std::string()) : ps(new std::string(s)), i(0) {}
        HasPtr(const HasPtr& p): ps(new std::string(*p.ps)), i(p.i) {}
        HasPtr& operator = (const HasPtr& rhs){
            std::string* tmp = new std::string(*rhs.ps);
            delete ps;
            ps = tmp;
            i = rhs.i;
            return *this;
        }
        HasPtr& operator = (HasPtr rhs){
            swap(*this, rhs); // 交换左侧对象和右侧对象的副本
            return *this;
        }
        ~HasPtr() {delete ps;}
    private:
        std::string *ps;
        int i; 
    };

    inline void swap(HasPtr &lhs, HasPtr &rhs){
        using std::swap;
        // 内置类型的数据可以使用标准库的swap
        swap(lhs.ps, rhs.ps);
        swap(lhs.i, rhs.i);
    }

    class Foo{
        friend void swap(Foo&, Foo&);
    private:
        HasPtr h;    
    };

    void swap(Foo &lhs, Foo &rhs){
        using std::swap;
        swap(lhs.h, rhs.h); // 使用HasPtr版本的swap
    }
  ```

## 对象移动

- 很多拷贝操作后，原对象会被立即销毁，因此引入移动操作可以大幅度提升性能。
- 在新标准中，我们可以用容器保存不可拷贝的类型，只要它们可以被移动即可。
  - 标准库容器、`string`和`shared_ptr`类既可以支持移动也支持拷贝。`IO`类和`unique_ptr`类可以移动但不能拷贝。

### 右值引用

- 新标准引入右值引用以支持移动操作。
- 通过`&&`获得右值引用，常规引用可以称之为左值引用
  - 左值引用：不能绑定到要求转换的表达式、字面常量或是返回右值的表达式
    - 生成左值：返回左值引用的函数，赋值、下标、解引用、前置递增递减运算符
    - 左值有持久的状态
  - 右值引用：可以绑定到要求转换的表达式、字面常量或是返回右值的表达式，但是不能绑定到一个左值上
    - 生成右值：返回非引用类型的函数，算数、关系、位、后置递增递减运算符
    - 右值要么是字面常量（没有其他用户），要么是表达式求值过程中创建的临时变量（即将被销毁）
    - 右值引用指向将要被销毁的对象，因此可以支持“移动”操作
- 变量表达式都是左值，所以不能将一个右值引用绑定到一个变量上，即使这个变量的类型是右值引用也不行

**move函数**：

- 可以获得绑定在左值上的右值引用
  - `int &&rr2 = std::move(rr1);`
- 定义在头文件utility中
- `move`告诉编译器，我们有一个左值，但我希望像右值一样处理它。
- 调用`move`意味着：除了对`rr1`赋值或者销毁它外，我们将不再使用它。
- 使用move的代码应该使用std::move而不是move，可以避免潜在的名字冲突

### 移动构造函数和移动赋值运算符

- **移动构造函数**：
  - 第一个参数是该类类型的一个引用，关键是，这个引用参数是一个**右值引用**。
  - `StrVec::StrVec(StrVec &&s) noexcept{}`
    - 在形参列表后添加关键字noexcept可以指明该函数不会抛出任何异常，在声明和定义中均应该指明noexcept
    - 不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept
      - 原因1：移动操作不分配资源，所以通常不会抛出异常（但抛出异常也是允许的）
      - 原因2：如果不能确定移动构造函数不抛出异常，那么在重新分配内存的过程中，就必须使用拷贝构造函数而非移动构造函数（如果用移动构造函数，移动到一半抛出异常，容器不能满足即使发生异常也保持自身不变的要求），因此需要显式标记noexcept
  - 不分配任何新内存，只是接管给定的内存（将源对象的资源所有权归属到新创建的对象）
  - 除了完成资源移动，还要确保移动后源对象是可以安全销毁的（比如将源对象中数组的指针指向nullptr，然后源对象进行正确析构，否则会释放掉刚才移动的对象），用户不能使用移动后源对象的值
  
- **移动赋值运算符**：
  - `StrVec& StrVec::operator=(StrVec && rhs) noexcept{}` 
- 使用非引用参数的单一赋值运算符可以实现拷贝赋值和移动赋值两种功能，依赖于实参的类型：实参是左值，则实参被拷贝；实参是右值，则实参被移动
  - `StrVec& operator=(StrVec rhs);`
- 更新三/五法则：如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。
- 移动迭代器：
  - 普通迭代器的解引用运算符返回一个指向元素的左值，移动迭代器的解引用运算符生成一个右值引用
  - `make_move_iterator`函数将一个普通迭代器转换为一个移动迭代器。
  - 因此，可以将移动迭代器传递给算法或是alloc的伴随算法(比如uninitialized_copy)
    - 但是，标准库不能保证哪些算法适用于移动迭代器，哪些不适用。由于移动一个对象可能销毁掉源对象，因此要确定以后不再访问这个元素时，才能将移动迭代器传递给算法
- 建议：小心地使用移动操作，以获得性能提升。
  - 移后源对象具有不确定的状态，必须确认移后源对象没有其他用户

**合成的移动操作**
- 如果一个类定义了自己的拷贝构造函数、拷贝赋值函数或者析构函数，编译器不会为它合成移动构造函数和移动赋值运算符
  - 如果一个类没有移动操作，类会用对应的拷贝操作来代替移动操作，即使使用move函数也是如此
- 只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动（内置类型可以移动，类类型要有对应的移动操作）时，编译器才会为类合成移动构造函数和移动赋值运算符
- 与拷贝操作不同，移动操作永远不会隐式定义为删除的函数
  - 但是如果显式的要求编译器生成=defalut的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为=deleted的函数
  - 如果移动操作被定义为=deleted的函数，编译器就不会合成它们
  - 如果一个类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝函数和拷贝赋值运算符会被定义为删除的
  - 定义了移动构造函数和移动赋值运算符的类必须也定义自己的拷贝操作，否则这些成员会被默认的定义为=deleted的函数

### 右值引用和成员函数

- 区分移动和拷贝的重载函数通常有一个版本接受一个`const T&`，而另一个版本接受一个`T&&`。
- 引用限定符：
  - 在参数列表后面防止一个`&`，限定只能向可修改的左值赋值而不能向右值赋值。
  
