# 第十三章 拷贝控制

先复习一下构造函数：
- 默认构造函数
  - 合成的默认构造函数：编译器创建
  - 无参数默认构造函数，最好用`=default`来修饰默认构造函数
  - 带默认值的构造函数
- 一般构造函数：
- 拷贝构造函数（或称为复制构造函数）：根据一个已存在的对象复制出一个新的对象，使用=进行拷贝构造
- 转换构造函数（或称为隐式的类型转换）
- 移动构造函数：经常用于临时对象初始化新对象时
- 委托构造函数：一个构造函数调用另一个构造函数
- 参考：[C++中的五种构造函数](https://blog.csdn.net/TABE_/article/details/116714304)、[C++的几种构造函数](https://blog.csdn.net/weixin_45677333/article/details/108933364)

初始化类型：
- 直接初始化：使用圆括号进行初始化
- 拷贝初始化：`=`
- 列表初始化：`{}`

**拷贝控制操作**（copy control）（或者称为拷贝控制成员）:
一个类通过定义五种特殊的成员函数来控制对象的拷贝、移动、赋值、和销毁操作：
- 拷贝构造函数（copy constructor）
- 拷贝赋值运算符（copy-assignment operator）
- 移动构造函数（move constructor）
- 移动赋值函数（move-assignement operator）
- 析构函数（destructor）

## 拷贝、赋值和销毁

### 拷贝构造函数(The Copy Constructor)

- 如果一个构造函数的第一个参数是**自身类类型的引用**（几乎总是const引用），且任何额外参数都有默认值，则此构造函数是**拷贝构造函数**。
  - `class Foo{ public: Foo(const Foo&); }`
- 拷贝构造函数在一些情况下会被隐式使用，所以通常不会声明为explicit的
- **合成的拷贝构造函数**（synthesized copy constructor）：类未定义自己的拷贝构造函数，编译器为类创建一个，会将参数的非static成员逐个拷贝到正在创建的对象中。
- **拷贝初始化**：
  - 将右侧运算对象拷贝到正在创建的对象中，如果需要，还需进行类型转换。
  - 通常使用拷贝构造函数完成。但如果一个类拥有移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数完成。
  - 出现场景：
    - 用`=`定义变量时。
    - 将一个对象作为实参传递给一个非引用类型的形参。
    - 从一个返回类型为非引用类型的函数返回一个对象。
    - 用花括号列表初始化一个数组中的元素或者一个聚合类中的成员。

### 拷贝赋值运算符(The Copy-Assignment Operator)

- **重载赋值运算符**：
  - 重写一个名为`operator=`的函数，通常返回一个指向其左侧运算对象的引用。
  - 标准库通常要求保存在容器中的元素中的类型要有赋值运算符，且其返回值是左侧对象的引用（`return *this;`）
  - `Foo& operator=(const Foo&);`
- **合成拷贝赋值运算符**：
  - 将右侧运算对象的每个非`static`成员赋予左侧运算对象的对应成员，之后返回左侧对象的引用

### 析构函数

- 释放对象所使用的资源，并销毁对象的非`static`数据成员。
- 名字由波浪号接类名构成。没有返回值，也不接受参数（因此不能被重载）。
- 如果没有定义析构函数，编译器会为类合成一个。合成析构函数的函数体为空。
- 析构函数体与数据成员的销毁是两个步骤（析构函数体本身并不直接销毁成员）
  - 函数体释放对象在生成周期分配的所有资源
  - 析构阶段：数据成员按照初始化顺序的逆序进行销毁，这部分是隐式的，成员销毁时发生什么完全依赖于成员的类型
    - 内置类型没有析构函数，因此销毁内置类型成员什么也不会发生
    - 隐式销毁一个内置指针类型不会delete它所指的对象，因此要在函数体中将指针所指的资源释放
    - 与普通指针不同，智能指针是一个类类型，具有析构函数，因此智能指针成员在析构阶段自动销毁
- 调用时机：
  - 变量在离开其作用域时。
  - 当一个对象被销毁时，其成员被销毁。
  - 容器被销毁时，其元素被销毁。
  - 动态分配的对象，当对指向它的指针应用`delete`运算符时。
  - 对于临时对象，当创建它的完整表达式结束时。

### 三/五法则

- 背景：一个类通常需要拷贝构造函数、拷贝赋值运算符、析构函数、移动构造函数、移动赋值运算符，部分操作会搭配使用，但是通常自己不会全部自定义
- 需要析构函数的类也需要拷贝和赋值操作：一个需要析构函数的类，一定也需要一个拷贝构造函数和拷贝赋值函数（比如类中有一个指向动态内存的指针）
- 需要拷贝操作的类也需要赋值操作，反之亦然（但未必需要析构函数）

### 使用=default

- 可以通过将拷贝控制成员定义为`=default`来显式地要求编译器生成合成的版本。
  - 只能对具有合成版本的成员函数【即默认构造函数或拷贝控制成员】使用=default
- 在类内部使用=default修饰成员声明时，合成的函数是隐式内联的；如果不希望合成的是内联函数，应该只对成员的类外定义使用=defalut

### 阻止拷贝（Preventing Copies）

- 背景：有的类需要禁止拷贝（比如iostream），但是单纯不定义拷贝控制成员是无效的，因为编译器会生成合成的版本。
- 语法：`=delete`，使用位置同=default，作用是禁用修饰的函数
  - =delete必须出现在函数第一次声明的地方（即告诉编译器不定义这些函数），而且可以对任何函数使用（但主要用途是禁止拷贝控制成员）
  - =delete不能修饰类或类成员的析构函数，否则类或类成员无法被销毁
    - 对于=delete修饰类或类成员的析构函数的情况，不能定义该类型的变量或成员，但是可以动态分配(new)该类型的对象，只是无法释放对象内存
- 使用场景与注意事项：
  - =delete修饰【拷贝构造函数和拷贝赋值函数】，可以禁止类对象的拷贝
  - 合成的拷贝控制成员可能是删除的
    - 如果一个类有数据成员不能被构造、拷贝、复制或销毁，则对应的成员函数（构造、拷贝、复制或销毁）将被定义为删除的
- 老版本使用`private`声明来阻止拷贝。
  - 声明但不定义private的拷贝构造函数，类不能使用该拷贝构造函数，友元试图访问一个未定义的成员导致一个编译阶段的链接错误

## 拷贝控制和资源管理

- 通常，管理类外资源的类必须定义拷贝控制成员
- 类的行为可以像一个值，也可以像一个指针（不允许拷贝和赋值的类，行为既不像值，也不像指针），主要是如何拷贝类的指针成员的行为：
  - 行为像值：对象有自己的状态，副本和原对象是完全独立的。
    - 拷贝赋值运算符要考虑到【自赋值】（对象赋予自身）的正确性：
      - 好的方法是先将右侧对象（动态内存的指针对象）拷贝到一个局部临时对象，再销毁左侧对象的资源。（P454）
  - 行为像指针：共享状态，拷贝一个这种类的对象时，副本和原对象使用相同的底层数据。
    - 最好使用shared_ptr管理资源，或者使用一个引用计数来直接管理（引用计数和资源一样是共享的）
    - 拷贝赋值运算符类似于shared_ptr，需要递增右侧对象的引用计数，递减左侧对象的引用计数
    - 此时处理【自赋值】问题：先是右侧对象引用计数递增，后是左侧对象引用计数递减，自赋值时引用计数不变（P457）

## 交换操作

- 管理资源的类通常还定义一个名为`swap`的函数，经常用于重排元素顺序的算法。
- 如果类没有定义自己的swap函数，就使用标准库定义的swap
- 如果存在特定类型的swap版本，匹配程度会优先于std中定义的版本（重载），尽量用自定义的swap
- 定义了swap的类通常用swap来是实现赋值运算符
  - 右侧对象传值，然后将左侧对象与右侧对象的副本进行交换（copy and swap），可以正确处理自赋值的情况
- 例子：
  ```c++
    class HasPtr{
        friend void swap(HasPtr&, HasPtr&);
    public:
        HasPtr(const std::string &s = std::string()) : ps(new std::string(s)), i(0) {}
        HasPtr(const HasPtr& p): ps(new std::string(*p.ps)), i(p.i) {}
        HasPtr& operator = (const HasPtr& rhs){
            std::string* tmp = new std::string(*rhs.ps);
            delete ps;
            ps = tmp;
            i = rhs.i;
            return *this;
        }
        HasPtr& operator = (HasPtr rhs){
            swap(*this, rhs); // 交换左侧对象和右侧对象的副本
            return *this;
        }
        ~HasPtr() {delete ps;}
    private:
        std::string *ps;
        int i; 
    };

    inline void swap(HasPtr &lhs, HasPtr &rhs){
        using std::swap;
        // 内置类型的数据可以使用标准库的swap
        swap(lhs.ps, rhs.ps);
        swap(lhs.i, rhs.i);
    }

    class Foo{
        friend void swap(Foo&, Foo&);
    private:
        HasPtr h;    
    };

    void swap(Foo &lhs, Foo &rhs){
        using std::swap;
        swap(lhs.h, rhs.h); // 使用HasPtr版本的swap
    }
  ```

## 对象移动

- 很多拷贝操作后，原对象会被销毁，因此引入移动操作可以大幅度提升性能。
- 在新标准中，我们可以用容器保存不可拷贝的类型，只要它们可以被移动即可。
- 标准库容器、`string`和`shared_ptr`类既可以支持移动也支持拷贝。`IO`类和`unique_ptr`类可以移动但不能拷贝。

### 右值引用

- 新标准引入右值引用以支持移动操作。
- 通过`&&`获得右值引用。
- 只能绑定到一个将要销毁的对象。
- 常规引用可以称之为左值引用。
- 左值持久，右值短暂。

**move函数**：

- `int &&rr2 = std::move(rr1);`
- `move`告诉编译器，我们有一个左值，但我希望像右值一样处理它。
- 调用`move`意味着：除了对`rr1`赋值或者销毁它外，我们将不再使用它。

### 移动构造函数和移动赋值运算符

- **移动构造函数**：
  - 第一个参数是该类类型的一个引用，关键是，这个引用参数是一个**右值引用**。
  - `StrVec::StrVec(StrVec &&s) noexcept{}`
  - 不分配任何新内存，只是接管给定的内存。
- **移动赋值运算符**：
  - `StrVec& StrVec::operator=(StrVec && rhs) noexcept{}` 
- 移动右值，拷贝左值。
- 如果没有移动构造函数，右值也被拷贝。
- 更新三/五法则：如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。
- 移动迭代器：
  - `make_move_iterator`函数讲一个普通迭代器转换为一个移动迭代器。
- 建议：小心地使用移动操作，以获得性能提升。

### 右值引用和成员函数

- 区分移动和拷贝的重载函数通常有一个版本接受一个`const T&`，而另一个版本接受一个`T&&`。
- 引用限定符：
  - 在参数列表后面防止一个`&`，限定只能向可修改的左值赋值而不能向右值赋值。
  
