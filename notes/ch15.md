# 第十五章 面向对象程序设计

## OOP：概述

- 面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。
- **继承**（inheritance）：构成一种层次关系
  - 通常在层次关系的根部有一个**基类**（base class）。
  - 其他类直接或者简介从基类继承而来，这些继承得到的类成为**派生类**（derived class）。
  - 基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。
  - 对于某些函数，基类希望它的派生类个自定义适合自己的版本，此时基类就将这些函数声明成**虚函数**（virtual function）。
    - 派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上`virtual`关键字，也可以不加。C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，注明`override`
  - 派生类必须通过使用**类派生列表**（class derivation list）明确指出它是从哪个基类继承而来。形式：一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前都可以有访问说明符。
- **动态绑定**（dynamic binding，又称运行时绑定）：
  - 使用基类的引用或指针调用一个虚函数时将发生动态绑定
    - 使用同一段代码可以分别处理基类和派生类的对象。
    - 函数的运行版本由实参决定，即在运行时选择函数的版本。
  - 例子：
    ```c++
      class Quote{
          public:
              string isbn() const;
              virtual double net_price(size_t n) const;
      };
      class Bulk_quote: public Quote{ 
          public:
              double net_price(size_t n) const override; // 派生类必须在内部对所有重新定义的虚函数进行声明
      };

      void func(Quote& q, int n){
          double val = q.net_price(n); // 此时无法确定用的是基类Quote中的new_price还是派生类Bulk_quote中的new_price，需要在运行时根据传入的对象来去确定
          cout<<val<<endl;
      }     
    ```

## 定义基类和派生类

### 定义基类

- 虚函数相关
  - 基类通常都应该定义一个【虚析构函数】，即使该函数不执行任何实际操作也是如此。
  - 除构造函数之外的任何非静态函数都可以定义为虚函数
  - virtual关键字只能出现在类内部的声明语句之前，而不能用于类外部的函数定义
  - 如果基类把一个函数声明为虚函数，则函数在派生类中隐式的也是虚函数
  - 成员函数如果没有被声明为虚函数，则其解析过程发生在编译阶段而非运行阶段
- 访问控制：派生类可以访问基类的共有成员，但是无法访问私有成员
  - `protected` ： 基类和和其派生类还有友元可以访问，外部无法访问
  - `private` ： 只有基类本身和友元可以访问。

### 定义派生类

- 【类派生列表（class derivation list）中的访问说明符】用于控制 派生类 从基类继承而来的成员 是否对派生类的用户可见
  - 派生类必须将继承而来的成员函数中需要覆盖的那些重新声明
  - 如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分，因此可以将派生类类型的对象绑定到基类的指针或引用上
- 【派生类中的虚函数】
  - 如果派生类没有覆盖基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员（即派生类会直接继承其在基类中的版本）
  - 派生类可以在它覆盖的函数前使用virtual关键字，但也可以不用
  - C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个`override`关键字。
- C++标准并没有明确规定派生类的对象在内存中如何分布，一个对象中继承自基类的部分和派生类自定义的部分不一定是连续存储的
- 【派生类到基类的类型转换】
  - 因为派生类对象中含有与基类对应的组成部分，所以能把派生类的对象当作基类对象来使用，也能将基类指针或引用绑定到派生类对象中的基类部分上
  - 编译器会隐式执行派生类到基类的类型转换
- 【派生类构造函数】：每个类控制自己的成员初始化过程
  - 派生类必须使用 基类的构造函数 来初始化它的基类部分
    - 遵循基类的接口，尽管从语法上可以在派生类中给基类的公有成员直接进行赋值
  - 派生类的构造函数 通过 构造函数初始化列表 来将实参传递给 基类构造函数
  - 除非特别指出，否则派生类对象的基类部分 会像 数据成员一样 执行默认初始化
  - 顺序：先初始化基类部分，在按声明顺序依次初始化派生类的成员
- 【静态成员】：如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一实例。
  - 静态成员遵循通用的访问控制规则
- 派生类的声明中不包含它的派生列表，派生列表必须于派生类的定义一起出现
- 如果想用某个类作为基类，该类必须已经定义而非仅仅声明
  - 一个类不能派生它本省
  - 直接基类与间接基类
- 防止继承：在类名后面跟一个关键字`final`。
  - final关键字除了防止继承，还可以防止函数被覆盖

### 类型转换与继承

- 理解【基类和派生类之间的类型转换】是理解C++语言面向对象编程的关键所在：使用基类的指针或引用时，并不清楚绑定对象的真实类型
  - 可以将基类的指针或引用绑定到派生类对象上。【左边小，右边大】
  - 不存在从基类向派生类的隐式类型转换。
  - 可以将一个派生类对象的指针存储在一个基类的智能指针内
- 基类的指针或引用的【静态类型与动态类型可能不一致】
  - 静态类型：变量或表达式类型在编译时已知
    - 比如静态类型是代码中写的类型，比如说可以是基类的引用类型
  - 动态类型：变量或表达式类型在运行时才可知，是指针指向的内存中对象的类型
    - 比如静态类型是基类的引用类型，但动态类型可以是派生类类型
- 不存在从基类向派生类的类型转换，不能【左边大，右边小】
  - 可以使用强制类型转换
    - 如果在基类中含有一个或多个虚函数，可以使用`dynamic_cast`，将基类的指针或引用 安全的转换成 派生类的指针或引用，该转换的安全检查将在运行期间执行
    - 如果已知某个基类到派生类的转换是安全的，可以使用`static_cast`强制覆盖掉编译器的检查工作
  - 例子：
  ```c++
      Quote a;
      Bulk_quote b;
      Quote* pa = &a;
      Bulk_quote* pb = &b;

      Bulk_quote* tb1 = dynamic_cast<Bulk_quote*>(pa);
      Bulk_quote* tb2 = static_cast<Bulk_quote*>(pa);  
  ```
- 派生类向基类的自动类型转换只对指针或引用类型有效，对象之间不存在类型转换。
  - 如果表达式既不是引用也不是指针，则它的静态类型与动态类型永远一致
  - 有时确实希望将派生类对象转换成基类类型
    - 派生类到基类的转换 给基类的拷贝/移动操作 传递给一个派生类的对象，这些操作是基类定义的（不是虚函数），只会处理基类自己的成员，派生类的部分被切掉(sliced down)了
 
## 虚函数

- 语法相关：
  - 必须为每一个虚函数提供定义，不管是否被用到（因为编译器也无法确定哪个虚函数会被使用，而且通常情况下，如果不使用某个函数，可以不为该函数提供定义）
  - 派生类必须在其内部对所有重新定义的虚函数进行声明，virtual关键字可加可不加，因为一旦某个函数在基类中被声明为虚函数，所有派生类中它都是虚函数
  - 一个派生类的函数如果覆盖了某个继承而来的虚函数，则两者形参类型必须相同，返回类型也相同
    - 返回类型不相同有一个例外：虚函数返回类型是类本身的指针或引用，比如类B派生出类D，则基类B的虚函数可以返回B*，而派生类D对应的函数可以返回D*
  - 派生类如果定义了一个与虚函数同名但是形参列表不同的函数，该函数与虚函数是相互独立的，但往往可能是不小心写错了
    - 因此，可以使用override关键字说明该函数是覆盖虚函数的，使得程序员的意图更加清晰
  - 默认实参
    - 如果指针/引用调用函数使用了默认实参，则实参的值由本次调用的指针/引用的【静态类型决定】
      - 因此可能使用的是基类中的默认实参，但是实际运行的是派生类的虚函数版本
    - 最好基类和派生类中的默认实参一致
  - 回避虚函数：对虚函数的调用不要进行动态绑定，而强迫执行虚函数的某个版本
    - 使用**作用域运算符**（`::`）来回避虚函数
    - 通常，只有成员函数（或友元）中才需要使用使用回避虚函数的机制，比如一个派生类的虚函数调用它覆盖的基类的虚函数版本（如果不使用回避机制，在运行时该调用将被解析为派生类版本自身的调用，导致无限循环递归）
    - 例子：
      ```c++
        double val = baseP->Quote::net_price(1); // 强行使用基类中定义的函数版本，不管BaseP的动态类型
      ```
    
- 特点：
  - 使用虚函数可以执行动态绑定。
  - 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。

- OOP的核心思想是多态性（polymorphism）。
  - 多态类型：具有继承关系的多个类型
  - 引用或指针的静态类型与动态类型不同是C++支持多态的根本

- 如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。
- 通常，只有成员函数（或友元）中的代码才需要使用**作用域运算符**（`::`）来回避虚函数的机制。

## 抽象基类

- **纯虚函数**（pure virtual）：清晰地告诉用户当前的函数是没有实际意义的。纯虚函数无需定义，只用在函数体的位置前书写`=0`就可以将一个虚函数说明为纯虚函数。
- 含有纯虚函数的类是**抽象基类**（abstract base class）。不能创建抽象基类的对象。

## 访问控制与继承

- 受保护的成员：
  - `protected`说明符可以看做是`public`和`private`中的产物。
  - 类似于私有成员，受保护的成员对类的用户来说是不可访问的。
  - 类似于公有成员，受保护的成员对于派生类的成员和友元来说是可访问的。
  - 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权。
- 派生访问说明符：
  - 对于派生类的成员（及友元）能否访问其直接积累的成员没什么影响。
  - 派生访问说明符的目的是：控制派生类用户对于基类成员的访问权限。比如`struct Priv_Drev: private Base{}`意味着在派生类`Priv_Drev`中，从`Base`继承而来的部分都是`private`的。
- 友元关系不能继承。
- 改变个别成员的可访问性：使用`using`。
- 默认情况下，使用`class`关键字定义的派生类是私有继承的；使用`struct`关键字定义的派生类是公有继承的。

## 继承中的类作用域

- 每个类定义自己的作用域，在这个作用域内我们定义类的成员。当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。
- 派生类的成员将隐藏同名的基类成员。
- 除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。

## 构造函数与拷贝控制

### 虚析构函数

- 基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。
- 如果基类的析构函数不是虚函数，则`delete`一个指向派生类对象的基类指针将产生未定义的行为。
- 虚析构函数将阻止合成移动操作。

### 合成拷贝控制与继承

- 基类或派生类的合成拷贝控制成员的行为和其他合成的构造函数、赋值运算符或析构函数类似：他们对类本身的成员依次进行初始化、赋值或销毁的操作。

### 派生类的拷贝控制成员

- 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。
- 派生类析构函数：派生类析构函数先执行，然后执行基类的析构函数。

### 继承的构造函数

- C++11新标准中，派生类可以重用其直接基类定义的构造函数。
- 如`using Disc_quote::Disc_quote;`，注明了要继承`Disc_quote`的构造函数。

## 容器与继承

- 当我们使用容器存放继承体系中的对象时，通常必须采用间接存储的方式。
- 派生类对象直接赋值给积累对象，其中的派生类部分会被切掉。
- 在容器中放置（智能）指针而非对象。
- 对于C++面向对象的编程来说，一个悖论是我们无法直接使用对象进行面向对象编程。相反，我们必须使用指针和引用。因为指针会增加程序的复杂性，所以经常定义一些辅助的类来处理这些复杂的情况。


## 文本查询程序再探

- 使系统支持：单词查询、逻辑非查询、逻辑或查询、逻辑与查询。

### 面向对象的解决方案

- 将几种不同的查询建模成相互独立的类，这些类共享一个公共基类：
  - `WordQuery`
  - `NotQuery`
  - `OrQuery`
  - `AndQuery`  
- 这些类包含两个操作：
  - `eval`：接受一个`TextQuery`对象并返回一个`QueryResult`。
  - `rep`：返回基础查询的`string`表示形式。
- 继承和组合：
  - 当我们令一个类公有地继承另一个类时，派生类应当反映与基类的“是一种（Is A）”的关系。
  - 类型之间另一种常见的关系是“有一个（Has A）”的关系。
- 对于面向对象编程的新手来说，想要理解一个程序，最困难的部分往往是理解程序的设计思路。一旦掌握了设计思路，接下来的实现也就水到渠成了。

**Query程序设计**:

| 操作 | 解释 |
|-----|-----|
| `Query`程序接口类和操作 |  |
| `TextQuery` | 该类读入给定的文件并构建一个查找图。包含一个`query`操作，它接受一个`string`实参，返回一个`QueryResult`对象；该`QueryResult`对象表示`string`出现的行。 |
| `QueryResult` | 该类保存一个`query`操作的结果。 |
| `Query` | 是一个接口类，指向`Query_base`派生类的对象。 |
| `Query q(s)` | 将`Query`对象`q`绑定到一个存放着`string s`的新`WordQuery`对象上。 |
| `q1 & q2` | 返回一个`Query`对象，该`Query`绑定到一个存放`q1`和`q2`的新`AndQuery`对象上。 |
| `q1 | q2` | 返回一个`Query`对象，该`Query`绑定到一个存放`q1`和`q2`的新`OrQuery`对象上。 |
| `~q` | 返回一个`Query`对象，该`Query`绑定到一个存放`q`的新`NotQuery`对象上。 |
| `Query`程序实现类 |  |
| `Query_base` | 查询类的抽象基类 |
| `WordQuery` | `Query_base`的派生类，用于查找一个给定的单词 |
| `NotQuery` | `Query_base`的派生类，用于查找一个给定的单词 |
| `BinaryQuery` | `Query_base`的派生类，查询结果是`Query`运算对象没有出现的行的集合 |
| `OrQuery` | `Query_base`的派生类，返回它的两个运算对象分别出现的行的并集 |
| `AndQuery` | `Query_base`的派生类，返回它的两个运算对象分别出现的行的交集 |
