# 第十五章 面向对象程序设计

## OOP：概述

- 面向对象程序设计（object-oriented programming）的核心思想是数据抽象、继承和动态绑定。
- **继承**（inheritance）：构成一种层次关系
  - 通常在层次关系的根部有一个**基类**（base class）。
  - 其他类直接或者简介从基类继承而来，这些继承得到的类成为**派生类**（derived class）。
  - 基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。
  - 对于某些函数，基类希望它的派生类个自定义适合自己的版本，此时基类就将这些函数声明成**虚函数**（virtual function）。
    - 派生类必须在其内部对所有重新定义的虚函数进行声明。可以在函数之前加上`virtual`关键字，也可以不加。C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，注明`override`
  - 派生类必须通过使用**类派生列表**（class derivation list）明确指出它是从哪个基类继承而来。形式：一个冒号，后面紧跟以逗号分隔的基类列表，每个基类前都可以有访问说明符。
- **动态绑定**（dynamic binding，又称运行时绑定）：
  - 使用基类的引用或指针调用一个虚函数时将发生动态绑定
    - 使用同一段代码可以分别处理基类和派生类的对象。
    - 函数的运行版本由实参决定，即在运行时选择函数的版本。
  - 例子：
    ```c++
      class Quote{
          public:
              string isbn() const;
              virtual double net_price(size_t n) const;
      };
      class Bulk_quote: public Quote{ 
          public:
              double net_price(size_t n) const override; // 派生类必须在内部对所有重新定义的虚函数进行声明
      };

      void func(Quote& q, int n){
          double val = q.net_price(n); // 此时无法确定用的是基类Quote中的new_price还是派生类Bulk_quote中的new_price，需要在运行时根据传入的对象来去确定
          cout<<val<<endl;
      }     
    ```

## 定义基类和派生类

### 定义基类

- 虚函数相关
  - 基类通常都应该定义一个【虚析构函数】，即使该函数不执行任何实际操作也是如此。
  - 除构造函数之外的任何非静态函数都可以定义为虚函数
  - virtual关键字只能出现在类内部的声明语句之前，而不能用于类外部的函数定义
  - 如果基类把一个函数声明为虚函数，则函数在派生类中隐式的也是虚函数
  - 成员函数如果没有被声明为虚函数，则其解析过程发生在编译阶段而非运行阶段
- 访问控制：派生类可以访问基类的共有成员，但是无法访问私有成员
  - `protected` ： 基类和和其派生类还有友元可以访问，外部无法访问
  - `private` ： 只有基类本身和友元可以访问。

### 定义派生类

- 【类派生列表（class derivation list）中的访问说明符】用于控制 派生类 从基类继承而来的成员 是否对派生类的用户可见
  - 派生类必须将继承而来的成员函数中需要覆盖的那些重新声明
  - 如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分，因此可以将派生类类型的对象绑定到基类的指针或引用上
- 【派生类中的虚函数】
  - 如果派生类没有覆盖基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员（即派生类会直接继承其在基类中的版本）
  - 派生类可以在它覆盖的函数前使用virtual关键字，但也可以不用
  - C++11新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，即在函数的形参列表之后加一个`override`关键字。
- C++标准并没有明确规定派生类的对象在内存中如何分布，一个对象中继承自基类的部分和派生类自定义的部分不一定是连续存储的
- 【派生类到基类的类型转换】
  - 因为派生类对象中含有与基类对应的组成部分，所以能把派生类的对象当作基类对象来使用，也能将基类指针或引用绑定到派生类对象中的基类部分上
  - 编译器会隐式执行派生类到基类的类型转换
- 【派生类构造函数】：每个类控制自己的成员初始化过程
  - 派生类必须使用 基类的构造函数 来初始化它的基类部分
    - 遵循基类的接口，尽管从语法上可以在派生类中给基类的公有成员直接进行赋值
  - 派生类的构造函数 通过 构造函数初始化列表 来将实参传递给 基类构造函数
  - 除非特别指出，否则派生类对象的基类部分 会像 数据成员一样 执行默认初始化
  - 顺序：先初始化基类部分，在按声明顺序依次初始化派生类的成员
- 【静态成员】：如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一实例。
  - 静态成员遵循通用的访问控制规则
- 派生类的声明中不包含它的派生列表，派生列表必须于派生类的定义一起出现
- 如果想用某个类作为基类，该类必须已经定义而非仅仅声明
  - 一个类不能派生它本身
  - 直接基类与间接基类：派生类构造函数只初始化它的直接基类
- 防止继承：在类名后面跟一个关键字`final`。
  - final关键字除了防止继承，还可以防止函数被覆盖

### 类型转换与继承

- 理解【基类和派生类之间的类型转换】是理解C++语言面向对象编程的关键所在：使用基类的指针或引用时，并不清楚绑定对象的真实类型
  - 可以将基类的指针或引用绑定到派生类对象上。【左边小，右边大】
  - 不存在从基类向派生类的隐式类型转换。
  - 可以将一个派生类对象的指针存储在一个基类的智能指针内
- 基类的指针或引用的【静态类型与动态类型可能不一致】
  - 静态类型：变量或表达式类型在编译时已知
    - 比如静态类型是代码中写的类型，比如说可以是基类的引用类型
  - 动态类型：变量或表达式类型在运行时才可知，是指针指向的内存中对象的类型
    - 比如静态类型是基类的引用类型，但动态类型可以是派生类类型
- 不存在从基类向派生类的类型转换，不能【左边大，右边小】
  - 可以使用强制类型转换
    - 如果在基类中含有一个或多个虚函数，可以使用`dynamic_cast`，将基类的指针或引用 安全的转换成 派生类的指针或引用，该转换的安全检查将在运行期间执行
    - 如果已知某个基类到派生类的转换是安全的，可以使用`static_cast`强制覆盖掉编译器的检查工作
  - 例子：
  ```c++
      Quote a;
      Bulk_quote b;
      Quote* pa = &a;
      Bulk_quote* pb = &b;

      Bulk_quote* tb1 = dynamic_cast<Bulk_quote*>(pa);
      Bulk_quote* tb2 = static_cast<Bulk_quote*>(pa);  
  ```
- 派生类向基类的自动类型转换只对指针或引用类型有效，对象之间不存在类型转换。
  - 如果表达式既不是引用也不是指针，则它的静态类型与动态类型永远一致
  - 有时确实希望将派生类对象转换成基类类型
    - 派生类到基类的转换 给基类的拷贝/移动操作 传递给一个派生类的对象，这些操作是基类定义的（不是虚函数），只会处理基类自己的成员，派生类的部分被切掉(sliced down)了
 
## 虚函数

- 特点：
  - 使用虚函数可以执行动态绑定。
  - 当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。
- 语法相关：
  - 必须为每一个虚函数提供定义，不管是否被用到（因为编译器也无法确定哪个虚函数会被使用，而且通常情况下，如果不使用某个函数，可以不为该函数提供定义）
  - 派生类必须在其内部对所有重新定义的虚函数进行声明，virtual关键字可加可不加，因为一旦某个函数在基类中被声明为虚函数，所有派生类中它都是虚函数
  - 一个派生类的函数如果覆盖了某个继承而来的虚函数，则两者形参类型必须相同，返回类型也相同
    - 返回类型不相同有一个例外：虚函数返回类型是类本身的指针或引用，比如类B派生出类D，则基类B的虚函数可以返回B*，而派生类D对应的函数可以返回D*
  - 派生类如果定义了一个与虚函数同名但是形参列表不同的函数，该函数与虚函数是相互独立的，但往往可能是不小心写错了
    - 因此，可以使用override关键字说明该函数是覆盖虚函数的，使得程序员的意图更加清晰
  - 默认实参
    - 如果指针/引用调用函数使用了默认实参，则实参的值由本次调用的指针/引用的【静态类型决定】
      - 因此可能使用的是基类中的默认实参，但是实际运行的是派生类的虚函数版本
    - 最好基类和派生类中的默认实参一致
  - 回避虚函数：对虚函数的调用不要进行动态绑定，而强迫执行虚函数的某个版本
    - 使用**作用域运算符**（`::`）来回避虚函数
    - 通常，只有成员函数（或友元）中才需要使用使用回避虚函数的机制，比如一个派生类的虚函数调用它覆盖的基类的虚函数版本（如果不使用回避机制，在运行时该调用将被解析为派生类版本自身的调用，导致无限循环递归）
    - 例子：
      ```c++
        double val = baseP->Quote::net_price(1); // 强行使用基类中定义的函数版本，不管BaseP的动态类型
      ```
- OOP的核心思想是多态性（polymorphism）。
  - 多态类型：具有继承关系的多个类型
  - 引用或指针的静态类型与动态类型不同是C++支持多态的根本

## 抽象基类

- **纯虚函数**（pure virtual）：清晰地告诉用户当前的函数是没有实际意义的
  - 纯虚函数无需定义，或者也可以提供定义，但是函数体必须定义在类的外部
  - 在函数体的位置前书写`=0`就可以将一个虚函数说明为纯虚函数，且=0只能出现在类内部的虚函数声明语句处
- 含有（或未经覆盖直接继承）纯虚函数的类是**抽象基类**（abstract base class）。
  - 抽象基类负责定义接口，后续的其他类可以覆盖该接口
  - 不能创建抽象基类的对象。
  - 如果派生类不覆盖抽象基类中的纯虚函数，则该派生类仍然是抽象基类
- 重构(refactor)：重新设计类的体系以便将操作、数据从一个类移动到另一个类中
  - 需要注意的是，即使改变了整个继承体系，那些使用这些类的代码也无须进行改动（保持接口不变）

## 访问控制与继承

- 类对其继承而来的成员的访问权限受到两个因素影响：基类中成员的访问说明符、派生类的派生列表中的访问说明符
- 受保护的成员protected：对于自己是private的，对于派生类和友元是public的
  - 外部无法访问，派生类的成员和友元可以访问
  - 派生类的成员或友元 只能通过【派生类对象（而不是基类对象）】来访问基类的受保护成员，即派生类中不能访问一个基类对象的protected成员
- 派生访问说明符：控制派生类用户对于基类成员的访问权限
  - 对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响（只与基类中成员的访问说明符有关）
  - 作用：基类中public/protected的成员，到了派生类中的访问说明
    - 如果继承是public的，则成员遵循原来的访问说明符
    - 如果继承是private的，则派生类中【从基类中继承而来的成员】是private的
    - 如果继承是protected的，则派生类中【从基类中继承而来的成员】是protected的
- 派生类向基类转换的可访问性，[示例说明](https://blog.csdn.net/monster_acm/article/details/81200777)
  - 总体原则：对于继承树中的某个节点，如果基类的共有成员是可以访问的，则派生类可以向基类进行类型转换；反之则不行
  - 只有当D公有的继承自B时，用户代码才能使用派生类到基类的转换
  - 不管D以什么方式继承B，【D的成员函数和友元函数】都能使用【派生类向基类的转换】，【派生类向其直接基类的类型转换】对于【派生类的成员和友元】而言永远都是可以访问的
  - 如果D继承B的方式是public的或protected的，则【D的派生类的成员和友元】可以使用【D向B的类型转换】；反之如果是私有的，则不能使用
- 友元关系是单向的，不具有传递性，且不能继承
  - 例子：
  ```c++
      class Base{
          friend class Pal;
          protected:
              int protected_val; // 每个类负责控制自己成员的访问权限，protected_val访问权限由Base控制（即使Base是内嵌在派生类对象中）
      };
      class Derived: public Base{
          friend class PPal;
          protected:
              int de_protected_val;
      };
      class Pal{ // 基类的友元
          public:
              int f(Derived d) {return d.protected_val;} // protected_val的访问控制权限由Baes控制，这种可访问性包括了Base对象内嵌在其派生类对象中的情况
              int g(Derived d) {return d.de_protected_val;} // error: 基类的友元不能随便访问派生类的成员
      };
      class DPal: public Pal{ // 基类友元的派生类
          public:
              int k(Derived d) {return d.protected_val;} // 友元关系不能继承
      };
      class PPal{ // 基类派生类的友元
          public:
              int h(Derived d) {return d.protected_val;}
      };
  ```
- 改变个别成员的可访问性：使用`using`。
  - 将基类的public/protected成员使用using进行标记，放在派生类public/protected/private的位置，就获得了相应的访问级别（因为有可能是private继承导致都是private访问级别）
  - 派生类只能为那些它可以访问的名字提供using声明，即基类的public/protected成员
- 默认情况下，使用`class`关键字定义的派生类是私有继承的；使用`struct`关键字定义的派生类是公有继承的。
  - class与struct之间唯二的差别就是：默认成员访问说明符、默认派生访问说明符，除此之外再无不同

## 继承中的类作用域

- 派生类的作用域嵌套在其基类的作用域之内
- 一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的，即使静态类型与动态类型可能不一致
  - 比如将派生类对象地址赋值给基类类型的指针，该指针无法调用派生类特有的成员
- 派生类的成员将隐藏同名的基类成员
  - 但是可以使用域运算符`::`使用被隐藏的基类成员
  - 除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字（但是成员函数无论是否为虚函数，都可以被重载）
  - 函数调用的解析过程：`p->mem()`或者`obj.mem()`
    1. 确定p或obj的静态类型
    2. 名字查找：在该静态类型对应的类中查找mem，如果找不到，则依次在直接继承中不断查找，知道到达继承链的顶端
    3. 类型检查：假如找到mem，进行常规的类型检查，以确认本次调用是否合法
    4. 假如合法，编译器根据调用的是否为虚函数产生不同的代码：
      - mem是虚函数且通过指针或引用来调用：编译器产生的代码将在运行时确定到底是运行该虚函数的哪个版本，依据是对象的动态类型
      - mem不是虚函数或者通过对象进行调用：产生一个常规的函数调用
- 名字查找先于类型检查
  - 重载、覆盖（重写）与隐藏，[参考](https://www.cnblogs.com/sunbines/p/9130227.html)
    - 重载：同一作用域内的几个函数同名但是形参列表不同
    - 隐藏：派生类中的函数屏蔽了与其同名的基类函数，不管参数列表是否相同
    - 覆盖（重写）：派生类中存在重新定义的函数，函数名、参数列表、返回值类型都必须与基类中被重写的函数一致，调用时调用动态类型指向的函数，基类中被重写的函数必须是虚函数
  - 派生类中同名的函数不会重载基类中的函数，而是**隐藏**基类中的函数，即使形参列表不相同（可以通过域运算符显式指明调用的函数）
  - 因此，基类与派生类中的虚函数要有相同的形参列表，派生类中函数**覆盖**基类虚函数，因此可以通过基类的指针或引用调用派生类的虚函数
- 覆盖重载的函数：[示例说明](https://blog.csdn.net/sinat_41619762/article/details/108176052)
  - 如果基类有一些同名不同参的函数func，如果派生类定义了一个函数func，就会将基类中的这些函数都覆盖掉
  - 如果想覆盖掉一些而非全部，可以使用using声明符将基类中的同名函数添加到派生类作用域中

## 构造函数与拷贝控制

### 虚析构函数

- 基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了（因为指针的静态类型与动态类型可能不一致，实际执行的是动态类型的析构函数）
  - 如果基类的析构函数不是虚函数，则`delete`一个指向派生类对象的基类指针将产生未定义的行为。
- 一般来说，如果一个类需要析构函数，那么它也需要拷贝和赋值操作，但是基类的析构函数不遵循该规则
- 虚析构函数将阻止合成移动操作（使用对应的拷贝操作来代替移动操作），因此基类和派生类都没有合成的移动操作

### 合成拷贝控制与继承

- 基类或派生类的合成拷贝控制成员的行为和其他合成的构造函数、赋值运算符或析构函数类似：他们对类本身的成员依次进行初始化、赋值或销毁的操作。
- **派生类中删除的拷贝控制与基类的关系**
  - 某些定义基类的方式 可能导致 有的派生类成员 成为被删除的函数：
    - 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的或者不可访问的函数，则派生类中对应的成员也会是被删除的。因为编译器不能使用基类成员来执行派生类对象中基类部分的构造、赋值或销毁操作。
    - 如果基类的析构函数是被删除的或者不可访问的，则派生类中合成的默认和拷贝构造函数也会是被删除的。因为编译器无法销毁派生类对象中的基类部分。
    - 编译器不会合成一个被删除的移动操作。当我们使用=default请求一个移动操作时，如果基类中对应的操作是被删除的或者不可访问的，则派生类中的操作也会是被删除的。因为派生类对象中的基类部分不能移动。同样，如果基类的析构函数是被删除的或者不可访问的，则派生类的移动构造函数也会是被删除的。
  - 在实际编程中，如果基类没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作。
- **移动操作与继承**
  - 默认情况下，会为基类定义虚析构函数，因此基类通常不含有合成的移动操作，而且它的派生类中也没有合成的移动操作
  - 因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时，应该首先在基类中显式定义，可以使用合成的版本，派生类也可以获得合成的拷贝控制
 
### 派生类的拷贝控制成员

- 当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。
- **定义派生类的拷贝或移动构造函数**
  - 当为派生类定义拷贝或移动构造函数时，通常使用 对应的基类构造函数 初始化 对象的基类部分
  - 在默认情况下，基类默认构造函数初始化派生类对象的基类部分。
- **派生类赋值运算符**
  - 派生类的赋值运算符必须显式地为其基类部分赋值，即调用基类赋值运算符进行基类部分的赋值，基类中的赋值运算符是显式定义的还是由编译器合成的无关紧要
- **派生类析构函数**
  - 和构造函数和赋值运算符不同，派生类的析构函数只负责销毁 由派生类自己分配的资源
  - 对象销毁的顺序与创建顺序相反：派生类析构函数先执行，然后是基类的析构函数
- **在构造函数和析构函数中调用虚函数**
  - 在基类初始化但是派生类部分未初始化，或者派生类部分销毁但是基类未销毁的情况下，该对象处于未完成的状态
  - 如果构造函数或析构函数调用了某个虚函数，则应该执行与构造函数或析构函数所属类型相对应的虚函数版本
  - [例子](https://zhuanlan.zhihu.com/p/424508028#:~:text=%E9%A6%96%E5%85%88%E7%BB%99%E5%87%BA%E7%AD%94%E6%A1%88%EF%BC%9A%20%E5%9C%A8C%2B%2B,primer%E4%B8%AD%E8%AF%B4%E5%88%B0%E8%BF%87%E6%98%AF%E6%9C%80%E5%A5%BD%20%E4%B8%8D%E8%A6%81%E8%B0%83%E7%94%A8%EF%BC%8C%E4%B8%8D%E6%98%AF%E4%B8%8D%E8%83%BD%E8%B0%83%E7%94%A8%EF%BC%8C%20%E6%89%80%E4%BB%A5%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%B7%9F%E8%99%9A%E6%9E%84%E5%87%BD%E6%95%B0%E9%87%8C%E9%9D%A2%E9%83%BD%E6%98%AF%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%EF%BC%8C%E5%B9%B6%E4%B8%94%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%8D%E4%BC%9A%E6%8A%A5%E9%94%99%E3%80%82)
- 例子：
  ```c++
    class Base{
      public:
        Base() {func();}
        Base(const Base&) =default;	
        Base(Base&&) =default;
        Base& operator= (const Base&) =default;
        Base& operator= (Base&&) =default;
        virtual ~Base() =default;
        virtual void func() {cout<<"Base"<<endl;}
    };
    class Derived: public Base{
        public:
        Derived(): Base() {func();} 
        Derived(const Derived& d): Base(d) {} // 在为派生类定义构造函数时，使用基类的构造函数初始化对象的基类部分
        Derived(Derived&& d): Base(d) {}
        Derived& operator= (const Derived& d){
          Base::operator=(d);
          /* do something*/
          return *this;
        }
        ~Derived() {/*销毁派生类自己分配的资源*/}
        virtual void func() {cout<<"Derived"<<endl;}
    };
    
    Derived d; // 在构造基类部分时，派生类部分还未被完全创建，此时将对象d当作一个基类对象，基类构造函数中func绑定的是Base的func
  ```

### 继承的构造函数

- 背景：如果基类有多个不同参数的构造函数，那么派生类也需要相应实现多个构造函数，[参考](https://blog.csdn.net/K346K346/article/details/81703914)
- 类不能继承【默认、拷贝和移动构造函数】，如果派生类没有直接定义这些构造函数，编译器会为派生类合成
- 派生类可以重用（非常规继承）其直接基类定义的构造函数，方法是提供一条注明了直接基类名的using声明语句
  - 通常情况下，using声明只是令某个名字在当前作用域中可见；但是当作用于构造函数时，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数
  - 派生类自己的数据成员被默认初始化
- 继承的构造函数的特点
  - 构造函数的using声明不会改变该构造函数的访问级别，基类公有，派生类中还是公有
  - 一个using声明不能指定explicit或constexpr，如果基类构造函数是explict的或constexpr的，则继承的构造函数也拥有相同的属性
  - 当一个基类构造函数有默认实参时，默认实参不会被继承，而是会产生多个不同参数个数的构造函数的版本
  - 基类有几个构造函数，派生类会继承所有的这些构造函数，除了两个例外：
    1. 派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本：如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则定义在派生类中的构造函数将替换继承而来的构造函数
    2. 默认、拷贝和移动构造函数不会被继承，这些构造函数按照正常规则被合成
    

## 容器与继承

- 当我们使用容器存放继承体系中的对象时，通常必须采用间接存储的方式。
  - 因为不允许容器中保存不同类型的对象，派生类对象直接赋值给基类对象，其中的派生类部分会被切掉。
- 在容器中放置（智能）指针而非对象。
- 对于C++面向对象的编程来说，一个悖论是我们无法直接使用对象进行面向对象编程。相反，我们必须使用指针和引用。因为指针会增加程序的复杂性，所以经常定义一些辅助的类来处理这些复杂的情况。


## 文本查询程序再探

- 使系统支持：单词查询、逻辑非查询、逻辑或查询、逻辑与查询。

### 面向对象的解决方案

- 将几种不同的查询建模成相互独立的类，这些类共享一个公共基类：
  - `WordQuery`
  - `NotQuery`
  - `OrQuery`
  - `AndQuery`  
- 这些类包含两个操作：
  - `eval`：接受一个`TextQuery`对象并返回一个`QueryResult`。
  - `rep`：返回基础查询的`string`表示形式。
- 继承和组合：
  - 当我们令一个类公有地继承另一个类时，派生类应当反映与基类的“是一种（Is A）”的关系。
  - 类型之间另一种常见的关系是“有一个（Has A）”的关系。
- 对于面向对象编程的新手来说，想要理解一个程序，最困难的部分往往是理解程序的设计思路。一旦掌握了设计思路，接下来的实现也就水到渠成了。

**Query程序设计**:

| 操作 | 解释 |
|-----|-----|
| `Query`程序接口类和操作 |  |
| `TextQuery` | 该类读入给定的文件并构建一个查找图。包含一个`query`操作，它接受一个`string`实参，返回一个`QueryResult`对象；该`QueryResult`对象表示`string`出现的行。 |
| `QueryResult` | 该类保存一个`query`操作的结果。 |
| `Query` | 是一个接口类，指向`Query_base`派生类的对象。 |
| `Query q(s)` | 将`Query`对象`q`绑定到一个存放着`string s`的新`WordQuery`对象上。 |
| `q1 & q2` | 返回一个`Query`对象，该`Query`绑定到一个存放`q1`和`q2`的新`AndQuery`对象上。 |
| `q1 | q2` | 返回一个`Query`对象，该`Query`绑定到一个存放`q1`和`q2`的新`OrQuery`对象上。 |
| `~q` | 返回一个`Query`对象，该`Query`绑定到一个存放`q`的新`NotQuery`对象上。 |
| `Query`程序实现类 |  |
| `Query_base` | 查询类的抽象基类 |
| `WordQuery` | `Query_base`的派生类，用于查找一个给定的单词 |
| `NotQuery` | `Query_base`的派生类，用于查找一个给定的单词 |
| `BinaryQuery` | `Query_base`的派生类，查询结果是`Query`运算对象没有出现的行的集合 |
| `OrQuery` | `Query_base`的派生类，返回它的两个运算对象分别出现的行的并集 |
| `AndQuery` | `Query_base`的派生类，返回它的两个运算对象分别出现的行的交集 |
