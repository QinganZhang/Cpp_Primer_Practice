# OOP

- 核心思想：数据抽象、继承和动态绑定

- class与struct：除此之外，再无不同

  |        | 默认成员访问说明符 | 默认派生访问说明符 |
  | :----: | :----------------: | :----------------: |
  | class  |      private       |      private       |
  | struct |       public       |       public       |

  

# 基类

## 访问控制：<span id="基类成员的访问说明符">基类成员的访问说明符</span>

- public：
- protected：对于基类的对象是private的，对于派生类成员和友元是public的
- private： 只有基类本身和友元可以访问

## 虚函数相关

- 除构造函数之外的任何非静态函数都可以定义为虚函数
- [虚析构函数](#虚析构函数)：基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。
- 用virtual声明：virtual关键字只能出现在类内部的声明语句之前，而不能用于类外部的函数定义
- 虚属性继承：如果基类把一个函数声明为虚函数，则函数在派生类中隐式的也是虚函数
- 运行时解析：普通成员函数的解析过程发生在编译阶段，虚函数的解析过程发生在运行阶段

# 派生类

## 访问控制：<span id="派生列表中的访问说明符">派生列表中的访问说明符</span>

- 派生类列表：派生访问说明符+基类名。其中，派生访问说明符说明从基类继承而来的成员，在派生类中的访问权限
  - 如果继承是public的，则成员遵循原来的访问说明符
  - 如果继承是private的，则从基类继承而来的成员，在派生类中是private的
  - 如果继承是protected的，则从基类继承而来的成员，在派生类中是protected的

## 虚函数相关

- 声明相关：
  - virtual关键字可加可不加
  - override：可以显式注明该函数是override（重写或覆盖）基类的虚函数
    - 因为派生类如果定义了一个与虚函数同名但是形参列表不同的函数，该函数与虚函数是相互独立的，但往往可能是不小心写错了
- 基类中的虚函数要覆盖吗？
  - 覆盖，则必须重新声明，且形参列表与返回值类型都必须与基类的相同
    - 返回类型不相同有一个例外：虚函数返回类型是类本身的指针或引用。比如类B派生出类D，则基类B的虚函数可以返回B\*，而派生类D对应的函数可以返回D\*
  - 不覆盖，直接继承在基类中的版本

## 类型转换

- 原理：一个派生类对象包含多个组成部分：一部分是派生类自己定义的成员，另一个部分是继承的基类成员

  - 逻辑上是一个整体，但具体在内存上未必连续存储

- 派生类向基类的转换

  - 将基类的指针或引用绑定到派生类对象上，因此基类指针或引用的静态类型与动态类型可能不一致（比如静态类型是指针声明时的类型，但是动态类型可能是派生类类型）
    - 静态类型：变量或表达式类型在编译时已知
    - 动态类型：变量或表达式类型在运行时才可知，是指针指向的内存中对象的类型
  - 派生类向基类的自动类型转换只对指针或引用类型有效
    - 如果表达式不是指针或引用，则它的静态类型与动态类型永远一致
    - 可以将派生类对象转换成基类类型，实际上将基类部分传递给基类的拷贝/移动控制成员，派生类部分被切掉

- 不存在从基类向派生类的转换，例外：

  - 将基类指针转换成派生类指针，使用强制类型转换

    - 使用`dynamic_cast`，将基类指针转换为派生类的指针，在运行时进行安全检查

    - 如果已知该转换是安全的，使用`static_cast`强制覆盖掉编译器的检查工作

      ```c++
      Base b, *pb = &b;
      Derived d, *pd = &d;
      Derived *pd2 = dynamic_cast<Derived*>(pb);
      Derived *pd3 = static_cast<Derived*>(pb);
      ```

- <span id="派生类向基类转换的可访问性">派生类向基类转换的可访问性</span>：在有了[派生访问说明符](#派生列表中的访问说明符)后，派生类向基类的类型转换。[示例](https://blog.csdn.net/monster_acm/article/details/81200777)

  - 总体原则：如果基类的公有成员是可访问的，则可以进行D向B的转换的转换
    - 只有当D public地继承B时，才能【在类外部】进行D向B的转换
    - 不管何种继承方式，【在D的成员函数和友元中】，都能进行D向B的转换
    - 如果D public/protected地继承B时，【在D的派生类的成员和友元中】，可以进行D向B的转换


## 成员

### 构造函数

- 派生类使用基类的构造函数来初始化它的基类部分（尽管从语法上对基类的公有成员直接赋值确实可行）
  - 使用构造函数初始化列表将实参传递给基类构造函数
- 先初始化基类部分，再按声明顺序初始化派生类成员

### 静态成员

- 如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一实例。
- 静态成员遵循通用的访问控制规则

### 其他

- 派生类的声明中不包含派生类列表，派生类列表必须与派生类的定义一起出现
- 如果想用某个类作为基类，该类必须已经定义而非仅仅声明
- final关键字
  - 禁止函数被继承
  - 防止虚函数被override（禁止派生类继续覆盖该虚函数）

# 多态

## 虚函数

- 背景：基类希望派生类自定义适合自己的版本，即动态绑定
- 引用或指针的静态类型与动态类型不同是C++支持多态的根本

### 语法

- 只有通过指针或引用调用虚函数时，才会在运行时进行解析

- 必须为每一个虚函数提供定义，不管是否被用到（因为编译器也无法确定哪个虚函数会被使用，而且通常情况下，如果不使用某个函数，可以不为该函数提供定义）

- 默认实参：在虚调用中，默认实参的值由指针/引用的静态类型决定

  - 因此可能出现：指针静态类型是基类，动态类型是派生类，虚调用时，使用基类虚函数的默认实参，运行派生类虚函数版本
  - 因此最好基类和派生类中的默认实参一致

- 回避虚函数：对虚函数的调用不要进行动态绑定，而强迫执行虚函数的某个版本（使用域运算符）

  - 通常，只有成员函数（或友元）中才需要使用，比如派生类的虚函数调用它覆盖的基类的虚函数版本

    ```c++
    baseP->Base::func(); // baseP动态类型未知，静态类型为基类指针
    ```

  - 否则在运行时该调用将被解析为派生类版本虚函数自身的调用，导致无限循环递归

### 动态绑定

- 背景：使用基类的引用或指针，调用一个虚函数时，发生动态绑定
  - 使用同一段代码可以分别处理基类和派生类的对象。
  - 函数的运行版本由实参决定

## 纯虚函数

- 作用：为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。
- 语法
  - 使用`=0`表明该虚函数是纯虚函数，且`=0`只能出现在类内部的虚函数声明语句处
  - 纯虚函数无需定义，或者也可以提供定义，但是函数体必须定义在类的外部

## 抽象基类

- 抽象基类：含有（或未经覆盖直接继承）纯虚函数的类，负责定义接口
- 语法
  - 不能创建抽象基类的对象
  - 如果派生类不覆盖抽象基类中的纯虚函数，则该派生类仍然是抽象基类

# 访问控制

## 访问权限

- 每个类负责自己成员的访问权限
  
- 派生类对象对基类成员的访问权限受到两个因素影响
  - [成员的访问说明符](#基类成员的访问说明符)：派生类可以访问基类中的public/protected成员

  - [派生列表中的访问说明符](#派生列表中的访问说明符)：基类中public/protected的成员经过继承，在派生类中的访问权限

- [派生类向基类转换的可访问性](#派生类向基类转换的可访问性)

- 改变个别成员的访问权限
  - 背景：private继承导致基类成员在派生类中都是private访问级别
  - 将基类的public/protected成员使用using进行标记，放在派生类public/protected/private的位置，就获得了相应的访问级别

## 类作用域

- 派生类的作用域嵌套在其基类的作用域之内

- 函数调用的解析过程：`p->mem()`或`obj.mem()`

  - 确定p或obj的静态类型
  - 名字查找：在该静态类型对应的类中查找mem，如果找不到，则依次在直接继承中不断查找，直到到达继承链的顶端
    - 类对象的静态类型决定了哪些成员对该类对象是可见的，即使静态类型与动态类型可能不一致。比如将派生类对象地址赋值给基类类型的指针，但是该指针无法调用派生类特有的成员
  - 类型检查：假如找到mem，进行常规的类型检查，以确认本次调用是否合法
  - 假如合法，编译器根据调用的是否为虚函数产生不同的代码：
    - mem是虚函数且通过指针或引用来调用：编译器产生的代码将在运行时确定到底是运行该虚函数的哪个版本，依据是对象的动态类型
    - mem不是虚函数或者通过对象进行调用：产生一个常规的函数调用

- 隐藏、覆盖（重写，override）和重载

  - 隐藏：派生类中的函数屏蔽基类中与其同名的函数，不管参数列表是否相同
    - 但是可以通过域运算符`::`显式指明调用的函数
  - 覆盖：派生类中见基类中的虚函数重新定义，函数名、参数列表、返回值类型都必须与基类中虚函数相同
  - 重载：同一作用域内的几个函数同名但是形参列表不同

- 特殊情况：基类虚函数重载，派生类只覆盖一个版本的虚函数，会隐藏基类中其他重载版本的虚函数，<span id="using">使用`using`声明</span>，[参考](https://blog.csdn.net/sinat_41619762/article/details/108176052)

  ```c++
  class Base {
      public:
      	// 基类有多个重载的虚函数（同名不同参）
          virtual int func() {return 0;}
          virtual int func(int i) {return 1;}
  };
  class D : public Base {
      public:
      	// 如果派生类希望基类中虚函数的所有重载版本都可见，就需要覆盖每一个虚函数的重载版本，烦琐
          int func() { return 2; }
  };
  class E: public Base{
      public:
      	using Base::func; // 使用using声明，将基类func的所有重载版本都添加到派生类的作用域中，func可以不是虚函数
  	    int func() { return 3; }
  }
  
  int main(){
      D d, *pd = &d; // 静态类型与动态类型都是D
      E e, *pe = &e; // 静态类型与动态类型都是E
      Base *BasePd = &d, *BasePe = &e; // 静态类型与动态类型是不同
      
      cout<<pd->func()<<endl;
      cout<<pd->func(1)<<endl; // 报错，该派生类中只覆盖了int func()版本的虚函数，int func(int)重载版本就被隐藏了
      
      cout<<BasePd->func()<<" "<<BasePd->func(1)<<endl; // 输出：2 1，进行了动态绑定
      cout<<BasePe->func()<<" "<<BasePe->func(1)<<endl; // 输出：3 1，动态绑定+using声明	
  }
  ```

## 友元

### 友元基础（第七章内容）

- 作用：可以允许其他类或函数访问它的非公有成员
- 类型
  - 友元类：友元类的成员函数可以访问此类所有成员
  - 友元函数
- 语法：
  - 友元关系不存在传递性，是单向的
  - 友元不是类的成员，不受访问控制的约束
  - 友元函数可以直接定义在类的内部，这种函数是隐式内联的。但是必须在类外部提供相应声明令函数可见

### 友元与继承

- 每个类负责自己成员的访问权限

- 友元关系不能继承

  - 【基类的友元】在访问派生类成员时，不具有特殊性（即只能访问派生类public成员）

- 友元关系只对做出声明的类有效

  - 【基类的友元的派生类】在访问基类时，不具有特殊性

- 例子

  ```c++
  class Base{
  	friend class Pal;
  	protected:
  		int protected_val; // protected_val访问权限由Base控制（即使Base是内嵌在派生类对象中）
  	private:
  		int private_val;		
  };
  class Derived: public Base{
  	friend class DPal;
  	protected:
  		int derived_protected_val;
  };
  class Pal{ // 基类的友元
  	public:
  		int f(Derived d) {return d.protected_val;} 
  		int g(Derived d) {return d.derived_protected_val;} // error: 基类的友元不能随便访问派生类的成员
  	protected:
  		int Pal_id;		
  };
  class PPal: public Pal{ // 基类的友元的派生类
  	public:
  		int k(Derived d) {return d.protected_val;} // error：友元关系不能继承
  		int s(Base b) {return b.protected_val;} // error：友元关系不能继承
  		void show() {cout<<Pal_id<<endl;} // 友元关系只对做出声明的类有效
  };
  class DPal{ // 派生类的友元
  	public:
  		int h(Derived d) {return d.protected_val;}
  };
  ```

# 拷贝控制

## <span id="虚析构函数">虚析构函数</span>

- 基类通常应该定义一个虚析构函数
  - 否则，如果delete一个指向派生类对象的基类指针，只会删除基类部分，造成内存泄漏；而定义之后会使用派生类的虚构函数，逐层析构
- 基类中虚析构函数的虚属性会继承，因此合成的析构函数还是自定义的析构函数都是虚函数
- 一般来说，如果一个类需要析构函数，那么它也需要拷贝和赋值操作，但是基类的析构函数不遵循该规则
- 虚析构函数将阻止合成移动操作，因此基类和派生类都没有合成的移动操作
  - 因为如果定义析构函数，说明要进行一些自定义的操作，然而移动操作之后数据已经无效，因此会阻止合成移动操作，使用对应的拷贝操作来代替移动操作

## 继承的构造函数

- 背景

  - 类不能继承默认、拷贝和移动构造函数，如果派生类没有定义，则编译器进行合成
  - 如果基类有多个形参列表的构造函数，那么派生类也需要相应实现多个构造函数，烦琐

- 使用[using声明](#using)“继承”基类构造函数

  - 通常情况下，using声明只是令某个名字在当前作用域中可见；但是当作用于构造函数时，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数，派生类自己的数据成员被默认初始化

- 特点

  - 构造函数的using声明不会改变该构造函数的访问级别，基类中是public，派生类中还是public
  - 如果基类构造函数是explict的或constexpr的，则继承的构造函数也拥有相同的属性
  - 如果一个基类构造函数有默认实参，会产生多个不同参数个数的构造函数的版本
  - 基类有几个构造函数，派生类会继承所有的这些构造函数，除了两个例外：
    - 默认、拷贝和移动构造函数不会被继承，这些构造函数按照正常规则被合成
    - 如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数不会被继承

- 例子

  ```c++
  class Base{
  	public:
  		Base() =default;
  		Base(const Base& b) =default;
  		Base(Base&& b) =default;
  		Base(int i): val(i) {}
  		Base(char c): val(c) {}
  		Base(string str) {}
  		Base(double d, int i=1): val(d) {} // 带有一个默认实参的构造函数
  	protected:
  		int val;
  };
  class Derived: public Base{
  	public:
  		using Base::Base;
  		Derived(string str): Base(str[0]) {}
  		/*
  		// 相当于对基类的每个构造函数，在派生类中生成一个形参列表完全相同的构造函数
  		// 生成的构造函数形如：Derived(params): Base(args) {}，其中Derived是派生类类名，Base是基类类名
  		Derived(int i): Base(i) {}
  		Derived(char c): Base(c) {}
  		Derived(double d, int i): Base(d) {} // do something for i // 这两个构造函数是由带默认实参的构造函数产生
  		Derived(double d): Base(d) {} // do something for i = 1 // 一个版本没有默认实参，另一个版本将默认实参固定i=1（相当于少了一个参数）
  		// 没有继承默认、拷贝、移动构造函数
  		// 没有生成: Derived(string str): Base(str) {}
  		*/
  		void show() {cout<<val<<endl;}
  };
  ```

## 合成拷贝控制的继承

- 在实际编程中，如果基类没有默认、拷贝或移动构造函数，则一般情况下派生类也不会定义相应的操作
- 基类中的某些操作会导致某些派生类成员成为被删除的函数
  - 如果基类中的【默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数】是被删除的或者不可访问的函数，则派生类中对应的成员也会是被删除的（因为派生类中基类部分不能进行拷贝控制）
  - 如果基类的【析构函数】是被删除的或者不可访问的，则派生类中【合成的默认和拷贝构造函数、移动构造函数】也会是被删除的（因为派生类中基类部分无法析构）
  - 如果基类的移动操作是被删除的或这不可访问的，则派生类中移动操作也是被删除的（因为派生类中基类部分无法移动）
- 基类中移动操作的继承
  - 背景：
    - [虚析构函数将阻止合成移动操作](#虚析构函数)，因此基类和派生类都没有合成的移动操作
    - 基类缺少移动操作会阻止派生类拥有自己的合成移动操作（因为派生类中基类部分无法移动）
  - 当确实需要移动操作时，应该在基类中显式定义，也可以使用合成版本（使用``=default`显式说明），同时也必须显式定义拷贝操作（因为显式定义了移动操作后，相应的拷贝操作就被定义为删除的）

## 派生类的拷贝控制成员

- 原则：当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。

  - 派生类的拷贝/移动构造函数：通常使用对应的基类构造函数初始化派生类的基类部分，否则会使用基类默认构造函数
  - 派生类的赋值运算符：必须显式地为其基类部分赋值，使用基类的赋值运算符可以时显式定义或合成的
  - 例外：派生类的析构函数
    - 和构造/拷贝操作不同，派生类的析构函数只负责销毁由派生类自己分配的资源
    - 对象销毁的顺序与创建顺序相反：派生类析构函数先执行，然后是基类的析构函数

- 特殊情况：如果【基类初始化但是派生类部分还未初始化，或者派生类部分销毁但是基类还未销毁】，此时该对象处于未完成的状态

  - 如果构造函数或析构函数调用了某个虚函数，则应该执行与构造函数或析构函数所属类型相对应的虚函数版本

- 例子

  ```c++
  class Base{
  	public:
      	Base() {func();}
  	    Base(const Base&) =default;	
      	Base(Base&&) =default;
  	    Base& operator= (const Base&) =default;
      	Base& operator= (Base&&) =default;
  	    virtual ~Base() =default;
      	virtual void func() {cout<<"Base"<<endl;}
  };
  class Derived: public Base{
      public:
      	Derived(): Base() {func();} 
  	    Derived(const Derived& d): Base(d) {/*init Derived part*/} // 使用基类的构造函数初始化派生类的基类部分
      	Derived(const Derived& d, bool test) {} // 使用Base::Base()进行基类部分的初始化，通常不这么做
      	Derived(Derived&& d): Base(std::move(d)) {/*move Derived part*/}
  	    Derived& operator= (const Derived& d){
      	    Base::operator=(d); // 使用基类的赋值运算符为派生类的基类部分赋值
          	/* do something*/
  	        return *this;
      	}
  	    ~Derived() {/*销毁派生类自己分配的资源*/}
      	virtual void func() {cout<<"Derived"<<endl;}
  };
  
  Derived d; // 在构造基类部分时，派生类部分还未被完全创建，此时将对象d当作一个基类对象，基类构造函数中func绑定的是Base的func
  // 输出：Base Derived
  ```

# 实践与经验

## 容器与继承

- 使用容器存放继承树中的对象时，通常必须采用间接存储的方式：存指针或智能指针
  - 因为不允许容器中保存不同类型的对象，派生类对象直接赋值给基类对象，其中的派生类部分会被切掉。


