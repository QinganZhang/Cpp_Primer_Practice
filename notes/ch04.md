# 第四章 表达式

## 表达式基础

- **运算对象转换**：小整数类型会被提升为较大的整数类型
- **重载运算符**：当运算符作用在类类型的运算对象时，用户可以自行定义其含义。
- **左值和右值**：
    - `C++`：一个对象当作左值时，用的是对象的地址；当作右值时，用的是对象的内容
    - 一个表达式要不就是左值，要不就是右值。左值可以用作右值
    - 表达式的返回值即返回值的类型?
    - `decltype`作用于表达式得到的不是左值（引用）就是右值（指针），作用于变量可以得到基本类型
- **求值顺序**：
  - 例1：`int i = f1() + f2()`
    - 先计算`f1() + f2()`,再计算`int i = f1() + f2()`。但是f1和f2的计算**先后不确定**（求值顺序与结合律等无关）
    - 但是，如果f1、f2都对同一对象进行了修改，因为顺序不确定，所以会编译出错，显示未定义
  - 例2：`int i = 0; cout<<i<<" "`<<++i<<endl;
    - 可能输出1 1，也可能输出0 1。（但测试了一下输出全是0 1）
    - 前后两个表达式指向并修改了同一个对象，可能会引发错误并产生未定义的行为
  - 只有4中运算符明确规定了求值顺序：`&&`、`||`、`?:`、`,`

## 算术运算符

- **溢出**：当计算的结果超出该类型所能表示的范围时就会产生溢出。
- **bool类型不应该参与计算**
  ```cpp
  bool b=true;
  bool b2=-b;   //仍然为true
  //b为true，提升为对应int=1，-b=-1
  //b2=-1≠0，所以b2仍未true
  ```
- 取余运算m%n，结果符号与m相同

## 逻辑运算符

- **短路求值**：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。**先左再右**
- 小技巧，**声明为引用类型可以避免对元素的拷贝**，如下，如string特别大时可以节省大量时间。
```cpp
vector<string> text;
for(const auto &s: text){
  cout<<s;
}
```

## 赋值运算符

- 赋值运算的**返回结果时它的左侧运算对象**，且是一个左值。类型也就是左侧对象的类型。
- 赋值运算符满足**右结合律**，这点和其他二元运算符不一样。 `ival = jval = 0;`等价于`ival = (jval = 0);`

## 递增递减运算符

* 前置版本`j = ++i`，先加一后赋值
* 后置版本`j = i++`，先赋值后加一

**优先使用前置**版本，后置多一步储存原始值。（除非需要变化前的值）

### 混用解引用和递增运算符

`*iter++`等价于`*(iter++)`，递增优先级较高

```c++
auto iter = vi.begin();
while (iter!=vi.end()&&*iter>=0)
	cout<<*iter++<<endl;	// 输出当前值，指针向前移1
```

> **简介是一种美德**，追求简洁能降低程序出错可能性

## 成员访问运算符

`ptr->mem`等价于`(*ptr).mem`

注意`.`运算符优先级大于`*`，所以记得加括号

## 条件运算符

- 条件运算符（`?:`）允许我们把简单的`if-else`逻辑嵌入到单个表达式中去，按照如下形式：`cond? expr1: expr2`

- 可以嵌套使用，**右结合律**，从右向左顺序组合

  - ```c++
    finalgrade = (grade > 90) ? "high pass"
        : (grade < 60) ? "fail" : "pass";
    //等价于
    finalgrade = (grade > 90) ? "high pass"
        : （(grade < 60) ? "fail" : "pass"）;
    ```

- 输出表达式使用条件运算符记得加括号，条件运算符优先级太低。

## 位运算符

用于检查和设置二进制位的功能。

- 位运算符是作用于**整数类型**的运算对象。
- 二进制位向左移（`<<`）或者向右移（`>>`），移出边界外的位就被舍弃掉了。
- 位取反（`~`）（逐位求反）、与（`&`）、或（`|`）、异或（`^`）

有符号数负值可能移位后变号，所以强烈建议**位运算符仅用于无符号数**。

应用：

```c++
unsigned long quiz1 = 0;    // 每一位代表一个学生是否通过考试
1UL << 12;  // 代表第12个学生通过
quiz1 |= (1UL << 12);   // 将第12个学生置为已通过
quiz1 &= ~(1UL << 12);  // 将第12个学生修改为未通过
bool stu12 = quiz1 & (1UL << 12);   // 判断第12个学生是否通过
```

> 位运算符使用较少，但是重载cout、cin大家都用过

位运算符满足左结合律，优先级介于中间，使用时尽量加括号。

## sizeof运算符

- 返回一条表达式或一个类型名字所占的**字节数**。
- 返回的类型是 `size_t`的常量表达式。
- `sizeof`并不实际计算其运算对象的值。
- 两种形式：
  1. `sizeof (type)`，给出类型名
  2. `sizeof expr`，给出表达式，返回表达式结果类型的大小
- 几种常见情况：
  - 对`char`或者类型为`char`的表达式执行`sizeof`运算，返回值为1。
  - 对引用类型执行`sizeof`运算得到被引用对象所占空间的大小。
  - 对指针执行`sizeof`运算得到指针本身所占空间的大小。
  - 对解引用指针执行`sizeof`运算得到指针指向的对象所占空间的大小，指针不需要有效。
  - 对数组执行`sizeof`运算得到整个数组所占空间的大小。
  - 对`string`或`vector`对象执行`sizeof`运算只返回该类型固定部分的大小，不会计算对象中元素所占空间的大小。

  ```c++
  int ia[10];
  constexpr size_t sz = sizeof(ia)/sizeof(*ia); // 返回数组的大小
  int arr[sz];
  ```

## 逗号运算符

从左向右依次求值。

左侧求值结果丢弃，逗号运算符**结果是右侧表达式**的值。

## 类型转换

### 隐式类型转换
- 隐式：指无需程序员介入，自动进行转换

#### 算术转换：整型提升

* 常见的char、bool、short能存在int就会转换成int，否则提升为`unsigned int`
* `wchar_t,char16_t,char32_t`提升为整型中`int,long,long long ……`最小的，且能容纳原类型所有可能值的类型。

#### 其他隐式类型转换

- 数组转换成指针：大多数情况下，数组名字自动转换成指向数组首元素的指针
- 指针的转换：常量整数值0或字面值nullptr能转换成任意指针类型；指向任意非常量的指针能转换成void*；指向任意对象的指针能转换成const void*
- 转换成布尔类型
- 转换成常量：指向非常量类型的指针能转换成指向相应的常量类型的指针
    ```c++
    int i = 0;
    const int *p = &i;
    const int &r = i;
    i = 9; // 可以通过i修改变量的值，但是不能通过p和r修改
    cout<<i<<" "<<*p<<" "<<r;
    ```

### 显式类型转换（尽量避免）
- 形式：`cast_name<type>(expression);`
  - type: 转换的目标类型，如果type是引用类型，则结果是左值
  - cast_name: static_case, dynamic_cast, const_cast, reinterpret_cast中的一种
  
    - **static_cast**：任何明确定义的类型转换，只要不包含底层const，都可以使用。 `double slope = static_cast<double>(j);`
	  - 把一个较大的算数类型赋值给较小的类型（可能有精度损失）
	  - 找回`void*`中的值

    - **dynamic_cast**：支持运行时类型识别。

    - **const_cast**：只能改变运算对象的底层const，将常量对象转化成非常量对象，一般可用于去除const性质。 `const char *pc; char *p = const_cast<char*>(pc)`
      - type必须是指针或者引用
      - 只有其可以改变常量属性
      - const可以是底层，也可以是顶层
		```c++
		int a = 2;
		const int *i = &a; // i是底层const
		int *j = const_cast<int*>(i);
		*j = 3;
		cout<<a<<" "<<*i<<" "<<*j; // 3 3 3

		const int a = 2;
		const int *i = &a; // i是底层const
		int *j = const_cast<int*>(i);
		*j = 3;
		cout<<a<<" "<<*i<<" "<<*j; // 2 3 3

		int a = 2;
		int const (*i) = &a; // i是顶层const
		int *j = const_cast<int*>(i);
		*j = 4;
		cout<<a<<" "<<*i<<" "<<*j; // 4 4 4
		```
	  - const_cast常用于有函数重载的上下文中

	- **reinterpret_cast**：通常为运算对象的位模式提供低层次上的重新解释。
	   ```c++
	   int *i;
	   char *c = reinterpret_cast<char*>(i); // 但是c所指的真实对象是一个int而非char
	   // char *c = (char*) i; // 旧式的强制类型转换，等价
	   ```
